# My North Star
- Don't take anything for granted
- A small plan, executed strongly (0% Stress, and 100% focus on inputs) is better than A Grand plan, executed weakly
---

### Mission Data Job Start 
#### Target (Initial) - Job in 24 Wks (by June 17, 2021)
#### Target (Revision 1) - Job in 32 Wks (by Aug 17, 2021)

---

### TABLE OF CONTENTS
<details>
<summary>Click to Expand/Collapse</summary>

### [POA](#POA) - My Plan of Action
### [Daily Activities](#Daily_Activity) - WBS - breaking POA into daily activities
### [Cheat Sheet](#Cheat_Sheet) - Learning during this journey
### [Job Search Keywords](#Job_search_keywords) - Job Search Keywords
### [Good Links](#Good_Links) - Good links for reference
### [Project Ideas](#Project_Ideas) - Project Ideas

</details>

---

### POA
<details>
<summary>Click to Expand/Collapse</summary>

| Part 1 | Part 2 | 
| :--- | :--- |
| Hard Skills: Product (I am the Product) improvment | Soft Skills: Marketing and Sales | 
| After inital setup: Full Weekends + try to find time on weekdays | After inital setup: ONLY on Weekdays |
| Kaggle(python + pandas) + Django + Canvas (in class + GitLab...while doing this course also go through Mongo https://www.youtube.com/watch?v=E-1xI85Zog8 and Flask https://www.youtube.com/watch?v=Z1RJmh_OqeA + Tablaue https://www.youtube.com/watch?v=TPMlZxRRaBQ + SQLite + SQLAlchemy) + Django again + AllKaggleCourses + AWS + (Kaggle Competitions...will also give you project ideas) + resources (text+video on my portfolio website) | Part 1: (Finding new ones) and Part 2: (Retaining) - RecruitmentAgencies + JobSupportGroups (Govt) + JobPortals + DirectCompanies + Internships + Notifications + Sharing on LinkedIn + LeetCode/other platforms | 

</details>  

---

### Study Plan
<details>
<summary>Click to Expand/Collapse</summary>

1. Python
    - Google Python Class - https://developers.google.com/edu/python
    - UofT Bootcamp exercises
    - UofT GitLab exercises
    - YouTube
2. Django / Flask

3. PostgreSQL standalone
    - all read/write SQL functions from Python 

4. AWS 
    - all read/write AWS functions from Python, using PostgreSQL DB

5. HTML website - inputting a text, calling AWS, running Python on AWS...

6. Machine Learning + Deep Learning

7. Tableau 

</details>  

---

### Daily_Activity
<details>
<summary>Click to Expand/Collapse</summary>

*Wk starts on a Monday and ends on a Sunday*

| Wk | Dates | Planned | Executed | Evaluation |
| :--- | :--- | :--- | :--- | :--- |
| 0 | 2020/12/07 - 2020/12/13 | Current Wk: Demo day + Relaxation | Bootcamp finished last Sunday (12/06) ## 1st 4 days of this week spent on Practicing for Demo day on Dec/10/2020. ## Sat/Sun spent relaxing | |
| 1 | 2020/12/14 - 2020/12/20  | Google's Python Class + laptop setup | New Laptop delivered on 12/14, Setting up new Laptop, partitioning (created D: for non-OS), Installing Git, Python, Anaconda - checking for opening .ipynb files from outside D:, copying files from oustside. ## Started Google Python class, found it was Python 2, so dropped this plan - found more courses on python.org, and W3 schools, but decided to go through UofT Bootcamp modules again ## 12/19 - Spent time on ways to create Video with Green backgound so that I could create educational videos and put on GitHub - tried Zoom, Logitech Capture, Logitech Gaming, OBS, Chroma Cam , Personify. ## 12/20 - Started with Bootcamp Python, moved to working on Career Service tasks - finished the intro, now working on others parts, decided to use the next 2 Wks to complete all tasks related to becoming Employee Ready and Employee Competitive and then revisit Hard/Soft Skills | Plan changed mid-wk |
| 2 | 2020/12/21 - 2020/12/27  | Complete tasks to become Employer-Ready | Change of plans - to Exercise everyday, am willing to push the Job start date by 2-4 months to achieve this. ##talked to career director (1st time) ## Completed first draft of brand statement, resume and LinkedIn | 100% completed |
| 3 | 2020/12/28 - 2021/01/03 | Work on GitHub profile and portfolio | ## Worked on GitHub profile (cleaned repos, descriptions, profile Readme ) ## Completed Portfolio on GitHub Pages (finalized template, tweaked it, worked on HTML, added pics, gif, embedded youtube) ## Started Kaggle Python course - https://www.kaggle.com/learn/python ## Year End and New Year Celebrations ## found the impressive profile of Aishwarya Srinivasan's on LinkedIn, liked her website as well  **the peculiar unicorn** | |
| 4 | 2021/01/04 - 2021/01/10 |  | ## RBC internship assessment ## Jan 10 - Received ***Kaggle certificate of completion - Python*** | |
| 5 | 2021/01/11 - 2021/01/17 |  | ## applied TDSB Can-Ex  ##Cleaned all pipeline @ office, and sent New Year emails ## got 1st feedback from CareerServices Team, implemented feedback ##submitted application for 'data analytics specialist' on gojobs.gov.on.ca form ##started Ontario Internship form ## edX University of Texas query ## wrote to UofT MScAC team ##resolved medicine issue | |
| 6 | 2021/01/18 - 2021/01/24 |  | ## CALC Can-Ex writing, speaking, infosession ## got 2nd feedback from CareerService Team, implemented and became Employer-ready ##talked to career director (2nd time)  ## career services event ## submitted Ontario Internship form ## Kaggle Pandas: 1-3 | |
| 7 | 2021/01/25 - 2021/01/31 |  | ## Signed up for Can-Ex ### Completed Kaggle Pandas ##  started Django video  ## Started Python consulting, and Upwork | |
| 8 | 2021/02/01 - 2021/02/07 |  | ## CanEx Week 1 - (Feb 4 and 5) ## went through all the jobs on the CareerServices JobBoard and applied to the ones which were applicable  ## PythonConsulting meeting ## Finished Bootcamp - Python | |
| 9 | 2021/02/08 - 2021/02/14 |  | ## CanEx Week 2: classes + assignments ## HackerRank python exercises ## started Kaggle - python again (finished lessons 1 and 2) | |
| 10 | 2021/02/15 - 2021/02/21 | | ## CanEx Week 3: classes + assignments  ## Mon, Feb 15 (Family Day) - Python(kaggle) + Python(Bootcamp) ## February 16th - CareerService - Resume/GitHub/LinkedIn/Brand-Statement, all became employer-competitive ### Feb 16th - xCS call - 8 PM, Feb 17th - xCS call @ 5 PM ## Wkend - a little Python classes 'Corey Schafer' + misc(RRSP + transfers + online shopping) + relaxation (snow mountain on Feb/20/2021) | |
| 11 | 2021/02/22 - 2021/02/28 | | ## CanEx Week 4: classes + assignments  ## Feb 24, Careeer Services session ## Feb 25 - talked to Career Director ## Wkend - started Pandas (Bootcamp)  | |    
| 12 | 2021/03/01 - 2021/03/07 | | ## CanEx Week 5: classes + assignments (1st placement to start next week) ## Finished kaggle Pandas | | 
| 13 | 2021/03/08 - 2021/03/14 | | ## CanEx Week 6: classes + assignments + 1st placement Week# 1:  ## Finished *Cheapr* assignment ## Finished Bootcamp's - Module 4-Pandas, started Module 5 - Matplotlib | | 
| 14 | 2021/03/15 - 2021/03/21 | | ## CanEx Week 7: No classes + No assignments ## Realized that 1st Co-op placement was NOT aligning with my career goals ## stressed out on Friday during CanEx class ## Weekend - Took time out to plan the direction of life - have to finish a Python course from Univeristy of Michigan https://www.coursera.org/specializations/python-3-programming , work on projects and then apply for Python projects -> Current Job (become the top ISR) ## wrote email to CALC to share my decision to drop ## First day out w/ family in Spring 2021 | |
| 15 | 2021/03/22 - 2021/03/28 | | ## CanEx Week 8 ## Dropped 1st Co-op placement ## Started Python 3 specialization - Univ of Michigan @ Coursera (has 5 courses) - finished course 1/5  | |
| 16 | 2021/03/29 - 2021/04/04 | | ## CanEx Week 9 ## Finished Course 2/5 of Python 3 specialization | |
| 17 | 2021/04/05 - 2021/04/11 | | ## CanEx Week 10 ## Finished Course 3/5 of Python 3 specialization | | 
| 18 | 2021/04/12 - 2021/04/18 | | ## CanEx Week 11 - April holiday week ## Finished Course 4/5 of Python 3 specialization | | 
| 19 | 2021/04/19 - 2021/04/25 | | ## CanEx Week 12 ## Finished Course 5/5 of Python 3 specialization ...this finished the Specialization       |   |
| 20 | 2021/04/26 - 2021/05/02 | | ## CanEx Week 13 ## Revised the Python 3 course, organized folders, downloded the Projects and created repo ## Apr 27 - got to know about the automation internship ## Office - created a PPT for a stretch assignment  ## Covid-19 1st shot # Monitor Arm search    |   |
| 21 | 2021/05/03 - 2021/05/09 | | ## CanEx Week 14 # 3 Co-op interviews *brain*, *RT*, *ISee* # filled out Spotify Internship application # chromecast search/ bike search (exising one got flat)  |   |
| 22 | 2021/05/10 - 2021/05/16 | | ## CanEx Week 15 # finalized *** Automation internship, paperwork, discussions ## Bike puncture fix ## | | 
| 23 | 2021/05/17 - 2021/05/23 | | ## CanEx Week 16 # discussion regarding internship ## long weekend - worked on portfolio/resume/notifications (Linkedin/Google/Indeed) | |
| 24 | 2021/05/24 - 2021/05/30 | | ## CanEx Week 17 # Internship Wk 1 - worked on the assignment | 
| 25 | 2021/05/31 - 2021/06/06 | | ## CanEx Week 18 # Internship Wk 2 - shared the work of assignment 1 | 
| 26 | 2021/06/07 - 2021/06/13 | | 

</details>

---

### PYTHON COURSE 1 - Univeristy of Michigan - Python 3 Specialization
<details>
<summary>Click to Expand/Collapse</summary>

- COURSE URL: https://www.coursera.org/specializations/python-3-programming
- TEXTBOOK: https://runestone.academy/runestone/books/published/thinkcspy/index.html
- TOPICS COVERED: 
- LIBRARIES COVERED: 
    - import <user_created_file>: to import user_created_file.py
        - it should be at the same level as the calling file, else have to use some additional code
        - the whole file will be executed, any print statement will be executed, good idea to have ONLY functions/classes in the external file
        - use the . operator to access its variables/methods
    - import turtle : for turtle graphics
    - import random: for random numbers
        - random.random() : for random float from 0 and 1
        - radom.randrange(optional_start_default_0, mandatory_end, optional_step_default_1)
        - radom.choice(iterable): chose random element from a iterable
    - import json: convert to and from json
        - loads(string): loads a string as a python_object
        - dumps(py_object, indent = 4): dumps a py_object to JSON 
    - import copy: to deepcopy(py_object)
    - import requests: to get the contents of a page using API 
        - page_response = requests.get(page_endpoint, params = my_params_as_dict)
        - py_obj = page_response.json()
    - import requests_cache: to cache page contents (which are in JSON, and were called used an API call)
        - to start caching: requests_cache.install_cache('my_cache_name')
        - to check if a page was retrieved from cache: page_response.from_cache
    - import webbrowser: (to open web pages)
        - webbrowser.open(url)
    - import PIL: Python image library
    - import pytesseract: image to text
    - import kraken: advanced image to text
    - import cv2: to detect faces
    - import pytest: to run tests using `assert`

- STRING METHODS: https://runestone.academy/runestone/books/published/thinkcspy/Strings/StringMethods.html
- LIST METHODS: https://runestone.academy/runestone/books/published/thinkcspy/Lists/ListMethods.html
- DICT METHODS: https://runestone.academy/runestone/books/published/thinkcspy/Dictionaries/Dictionarymethods.html
- STANDARD EXCEPTIONS: https://runestone.academy/runestone/books/published/thinkcspy/Exceptions/02_standard_exceptions.html

Number | Topic | Comments | Misc 
--- | --- |  --- | --- 
0.0 | Univeristy of Michigan | Python 3 Specialization |
0.1.1 | Way of the programmer | incremental programming - small and steady imporvements |
0.1.1.1 | type(), dir(), help(), id() | good way to check the working of python objects |
0.1.2 | Coding good practicce | use print statement regulary to keep checking output ...all print statements inside functions/classes|
0.1.3 | compound statements | statements that have their own indentations, like for-loop, with, def, class, while | 
1.0 | **1/5 - Python Basics** | https://www.coursera.org/learn/python-basics?specialization=python-3-programming |
1.1.1 | literals  | 0, 3.14, 'Hello World |
1.1.2 | operators and operands | Operators are + - * / (division) % (modulus/mod/reminder/integer reminder) // (int division OR truncated div operator; does not round) ** (exponentiation) ...// also works for floats, it returns a float |
1.1.2.1 | order of operands | evaluated left to right (exception exponents...2**3**2 = 2**9 NOT 8**2)....Parenthesis, Exponentiation, Multication, Division, Addiiton and Subtraction - PEMDAS |
1.1.2.2 | % (mod/moudulus) operator uses | to check divisibility if a num% other_number ==0, then it is divisible, cheking even/odd, if num % 2 == 0 even else odd, extracting the right most digits from a number, eg 1 right-most digit, do num%10, 2 right most digits num%100 | 
1.1.2.3 | // operator uses | to check integer division - num // 10 will return the tenth place number for example 20 // 10 equals 2 num // 100 will return the hundredth place number, eg 300 //3 equals 3 | 
1.1.3 | function calls | function are objects...called with the paranthesis...if called w/o the paranthesis they will return their type/id | 
1.1.4 | Data Types | int = integer, float = floating point number, strings .. strings can be enclosed in single quotes OR double quotes OR three single/double quotes ...triple quotes strings can span multiple lines | 
1.1.5 | Finding the type of a data | >>> type(23) >>> type('Hello World') >>> type(3.14) |
1.1.3 | Type conversion functions | int(), float(), str(), list(), tuple(dict) return a tuple of keys, list(dict) returns a list of keys | 
1.1.4 | common usage of conversion fn | (1) in print statement to print integers >>>`print('this is the result' + str(10) + 'and then ..')` (2) in input statement ...to take user input as integer >>> `int (input('Please enter something: '))` |
1.1.5 | Variables | a name that refers to a literal value ...created using assignment statements |
1.1.6 | assignment operator = | >>> name = 'James Bond' >>> pi = 3.14 ...read it as `I have a literal/variable/expression on the RHS and I am assigning its value to the variable on the LHS` ...in case of any Value error check the RHS first |
1.1.7 | Variable names | (1) cannot contain spaces (3) cannot be a python keyword https://runestone.academy/runestone/books/published/thinkcspy/SimplePythonData/VariableNamesandKeywords.html (3) no special characters, except for _ (4) cannot start with a number (5) convention is to start with a lowercase alphabet (except Class names)
1.1.8 | choosing good variable names | meaningful variables are easier to read/understand/document/debug | 
1.1.9 | reassignment | python variables can be reassigned ...data1 = 12, data1 = 13 |
1.1.10 | statements and expressions | statements are instuctions athat python can execute, eg. assignment statement, while, for, if, import ... expressions are a combination of literals, variables, operators and calls to functions. They need to be evaluated - the result of the evaluation is a value or object | 
1.1.11 | updating a variable | incremening/decrementing ... x += n is the same as x = x +n , x -= n is the same as x = x -n ...bumping is increasing by 1 | 
1.1.12 | hard-coding | using literals...make program less flexible...try to avoid | 
1.1.13 | Input | prompts the user to enter something, when pressed return it is interpreted by python...it can be assigned to a variable ...input only returns strings...to change to int, use the int type conversion >>> `int (input ('Enter something: '))`  | 
1.2.1 | Intro to Sequences/Collections |  ... collection data types are data types that can be broken down into smaller pieces (unlike integers and floats) ...collection data types can treated as a single entity or its individual parts may be referenced | 
1.2.2 | Strings | ordered collection of characters ...string with no characters is called an empty string and represented as '' OR "" | 
1.2.3 | Lists | ordered collection of data objects ...a list could have a mixture of ANY python data object - int, float, string, tuple, list, class, function ... it is recommended that a list have only one kind of data type, this ensures easier operation, understanding and debugging ...empty list = [] |  
1.2.4 | Tuples | Similar to lists that they are an ordered sequence and can have any python data type ...difference (1) use of curly braces (2) they are immutable ...to create a tuple with one value we have to include a comma after the value else the data is not treated as tuple...eg `type(5)` is `<class int>` `type(5,)` is `<class tuple>` |
1.2.5 | Indexing operator | from left to right: starts at 0, ends at ( len(sequence) -1 ) ... right to left: starts at -1 and ends at -len(sequence) ...representation, also called SUB ...list_name[2], string_name[2], tuple_name[2] |
1.2.6 | Lenght of a sequence | len () function | 
1.2.6 | The slice operator [:] | creates a new sequence >>> `sequence[x:y] ` will create a new sequence sliced out of the original sequence ...it will start at index x and go till index y ...if x is not mentioned, it starts at start of the list, if y is not mentioned it ends at the end of the list...if neither is mentioned, the entire original list is copied | 
1.2.7 | Concatenation and Repetition - strings, lists, tuples | concatenating using + >>> `new_single_string/list/tuple = string1/list1/tuple1 + string2/list2/tuple2` ...repetition using * >>> `new_single_string/list/tuple = string/list/tuple*5` ...NOTE: the new sequence will be a list will NOT have the original lists as sublists, but will have all the elements of the original listss as its elements.. for example a contac of 2 lists with 5 elements will be a new list with 10 elements | 
1.2.8 | .count() with string, list, tuple | counts the number of occurance in a string or list... >>> `string.count('string1')` ... >>> `list.count(element)` ... >>> `tuple.count(element)`|
1.2.9 | .index() with string, list, tuple | returns the index of the 1st occurance in a string or list... >>> `string.index('alphabet(s)')` ... >>> `list.index(element)` ... >>> `tuple.index(element)` | 
1.2.10 | .split() to split a string into a list of words | 'this is' to ['this', 'is'] ...>>> `string.split('split at')`...the default split is a whitespace, but it can be any character or combination of characters, like / - a ab , : ...eg >>> `'this,is,a,book'.split(',' )` ...common use case: splitting on , after reading from csv | 
1.2.11 | using .join() to join a list of strings into a string | >>> `'join with'.join(list)`...eg. '-'.join('Feb 12 2019') ...common use case: joining using , before writing as a csv | 
1.2.12 | Iteration |  |
1.2.13 | the for loop | syntax `for <loop_variable> in <iterable>:` ...it will iterate ONLY over the 1st level elements of the iterable and not inner level elements | 
1.2.14.1 | for loop in nested lists/dicts | iternation can be confusing in iterables that have nested data in lists/dict/tuples ...for example >>> `for element in [ [ [1, 2], [3,4] ], [ [5,6], [7,8] ], [ [9,10], [11, 12]] ]` ...the elements are [ [1, 2], [3,4] ] and not [1,2] or 1 ...to reach 1 we will have to use multiple iterations/for loops | 
1.2.14.2 | for loop - using the range function to create an iterable | >>> `for i in range(20)` will create an iterable starting with i as 0 and ending at 20-1 ...if using range to run a code x number of times, can use _ as the loop_variable ...range is very important when the length of iterable is not know but we want to access elements using the index ...>>> `for i in range(len(list)):` \n list[i] | 
1.2.15 | Booleans | True and False ... they are not strings  ...True is not equal to 'True' | 
1.2.16 | boolean expression, equality check, comparison/realational operators | equality check == ...returns True or False ... comparison != > < >= <= |
1.2.17 | logical operators | and or not |
1.2.18 | `in` and `not in` | returns True or False | 
1.2.19 | Precedence of operators | parentheses > exponent > multi > Divi > add > sub > relational (==, !=, >, <... ) > not  > and  > or  |
1.2.20 | Conditional: if-else | if catches a condition, else catches everythin else .... variations only 1 if, multiple ifs: if if if, one if one else, chained if elif elif elif |
1.2.21 | Sequence mutation | methods ...concatenate, index, slice, in/not in, find, append, join, split ... list are mutable, strings and tuples are immutable |
1.2.22 | ***LIST METHODS*** | https://runestone.academy/runestone/books/published/thinkcspy/Lists/ListMethods.html |
1.2.23 | some list methods | list_name.count(element), list_name.index(element), len(list_name), sum(list_name), min(list_name), max(list_name), random.choice(list_name), list_name.append(), list_name.pop(), list_name.pop(index), list_name[index] = replacement, list_name[x:y] = [...replacement elements], list_name[x:y] =[] (will delete between indexes x and y), del list_name[index], del list_name[x:y], `list_name.insert(index, value)` , list_name[x:x] = [...list to be inserted at index x] , list_name.remove(element) removes 1st occurance, list_name.sort(), sorted(list, key =function, reverse = True/False), list_name.reverse() ...also in and not in |
1.2.24 | LIST - ACCUMULATOR | list =[], list.append(element); for unique elements, >>> `if element not in list_name:` `list.append(element)` |
1.2.25 | Aliasing | Aliasing `list_new = list_original` does NOT generate a new copy, it keeps list_new pointed to list_original ...any chnages to list_original are reflected on the list_new |
1.2.26 | Copying | creating a new copy - for lists with no nesting, copy using list_name.copy() OR list_name[:] Or list_name*1| 
1.2.27 | ***STRING METHODS*** | https://runestone.academy/runestone/books/published/thinkcspy/Strings/StringMethods.html |
1.2.28 | some string methods | len(string_name), string_name.split(string), string.join(list_of_strings), string_name.upper(), string_name.lower(), string_name.count(substring), string_name.index(substring)...index of 1st occurance, string_name.replace(old_string, new_string)...replaces all occurances, string_name.strip(), string_name.format() , | 
1.2.29 | STRING: format string ...string.format(var1, var2) | >>> string1 = "This is part 1 of the string {:,.2f} This is part 2 of the string {,.2f} - This is part 3 of the string".format(var1, var2) | 
2.0 | **2/5 - Python Functions, Files, and Dictionaries** | https://www.coursera.org/learn/python-functions-files-dictionaries/home/welcome |
2.1 | **READING AND WRITING FILES NATIVELY** (w/o any library) | |
2.1.1 | CSV\TXT files are string files | data is stored as 1 single string, \n used for newline but it is still part of the 1 string | 
2.1.1 | loading the reference of a file | >>> `filepath = 'path of file'` \n >>> `with open(filepath, 'r') as file_reference:` |
2.1.2 | reading a file as 1 single string | \n >>> `file_as_1_string = file_reference.read()` ....can be used to select chars by indexing/slicing, eg >>> `char9 = file_reference.read()[8]` | 
2.1.3 | reading a file as lines (each line will be a string) | \n >>> `lines = file_reference.readlines()` ...can be used the access lines by looping and indexing/slicing ... `header_line = lines[0]` ...accessing character of a line lines[0][10] ...to acces the comma seperated values, break a line into a list of strings split at commas after stripping \n at the end...>>> `for line in lines:` \n `list_of_words = line.strip().split(',')` \n `for word in list_of_words:`|
2.1.4 | looping over lines without loading the file twice | >>> `filepath = 'path of file'` \n >>> `with open(filepath, 'r') as file_reference:` \n >>> `for lines in file_reference:` ... disadvantage (cannot refer to the lines using index, so cannot take off the header row), ADVANTAGE - faster, as it loads the file once | 
2.1.5 | writing to a file | same as above, (1) change 'r' to 'w', (2) writing to the file_reference >>> `file_reference.write(<only 1 single string can be written>)`, and (3) add a `\n` at the end of every line ...will have to reverse engineer reading of a file ...viz. creating lines - joining words into a string using ','.join(words) and adding \n at the end of every line, joining lines together into one single string at \n ...'\n'.join(list of lines) |
2.2 | **DICTIONARY** | |
2.2.1 | unordered items (key-value pairs) | notation {}, can be initilaized as an empty dict OR as a fully/partially filled dict |
2.2.2 | DICTIONARY OPERATIONS | ...almost all operations happen using keys, except for dict.values() and dict.items()  |
2.2.2.1 | access value using a key | >>> `dict_name['key_name']` | 
2.2.2.1.1 | key cannot be accessed using a value | | 
2.2.2.2 | add a key-value pair | >>> `dict_name['new_key_name'] = new_value` | 
2.2.2.3 | delete a key-value pair | >>> `del dict_name['key_name']`
2.2.2.4 | update a key-value pair | >>> `dict_name['key_name'] = new_value` | 
2.2.2.5 | update a key-value pair ... special case | >>> `dict_name['key_name'] += addition_value` | 
2.2.2.6 | checking the number of keys (items/key-value pairs) | >>> `len(dict_name)` | 
2.2.3 | DICTIONARY METHODS | ...almost all operations happen using keys ... eg `for key in dict_name`, `list(dict_name)`, `key in dict_name`, `sorted(dict_name, key = lambda dict_key : dict_name[dict_key])`  |
2.2.3.1 | returning the keys as a list | >>> `list(dict_name.keys())` ...this is useful as dictionaties cannot be indexed, but keys are unique, so this adds indexing to keys and values ... better way is >>> `list(dict_name)` |
2.2.3.2 | returning the values as a list | >>> `list(dict_name.values())` |
2.2.3.3 | returning the key-value pairss as a list of tuples | >>> `list(dict_name.items())` |
2.3.3.4 | Looping over a dict | |
2.2.3.4.1 | retrieving keys | >>> `for key in dict_name:` '\n' >>> `print(key)`  |
2.2.3.4.2 | retrieving values | >>> `for key in dict_name:` '\n' >>> `print(dict_name[key])`  |
2.2.3.4.3 | retrieving keys and values | >>> `for key in dict_name:` '\n' >>> `print(key, dict_name[key])`  |
2.2.3.5 | checking if a key is in a dict | >>> `print(key in dict_name)` ... returns True or False ... values can't be checked using this method | 
2.2.3.6 | trying to retrieve a key that is not is dict | results in a run time error - KeyError | 
2.2.3.6.1 | Solution to above - dict_name.get('key', alt) | return none if key is not in the dict, can return a alternate if key is not in the dict |
2.2.3.7 | DICTIONARY - Aliasing and copying | |
2.2.3.7.1 | cloning/copying a dict | >>> `new_dict = existing_dic.copy()` | 
2.2.3.8 | find char/words in a text and their frequencies | initiate empty dict, keys = chars/words, values = frequency, loop over the text, for each new char/word check `in` dict_name, if existing increase value, if not initaite and set value to 1 ... for key in dict_name: if key in dict: dict_name[key] += 1 else: dict_name[key] = 1 | 
2.2.3.9 | finding the max value or corresponding key in a dict | use sorted(dict, key = lambda x : dict[x]  )  |
2.3 | **FUNCTIONS** |  |
2.3.1 | Why? | used to reduce redundancy, decrease time and efforts, decrease errors, easier debugging | 
2.3.2 | defined using def | |
2.3.3 | Docstrings | good practice to describe the funtion using ''' this is the funtion :parmams: return: ...''' can the retrieved using >>> `help(function_name)` | 
2.3.4 | Requirements | def keyword mandatory, name is mandatory, parantheses, atleast one line of code, parameters optional, return optional, docstring optional | 
2.3.5.1 | parameters 1 | names of the parameters at the time of defining the functions are called the formal parameters or param names ...not available outside the function |
2.3.5.2 | parameters 2 | names of the parameters at the time of invoking the funcion are called Actual parameters or arguments or param values |
2.3.5.3 | parameters 3 | if the actual parameter (arguments / parameter passed) is a immutable object (num, str, tuple), then its value is not changed because of any operation inside the function; however for mutable objects it can changed if the object is changed at the id level...eg list.append('a') will change the list in the acutal parameter...it is a good idea to create a copy when using the parameter | 
2.3.5.4 | return | assigns the output to a variable ...default is None ... return terminates the funtion, and takes the code out of the current fn | 
2.3.5.5 | Decoding a Function | whenever enountered with a fn, try to find out (1) how many params does it have (2) what are the types (3) what is the type of return |
2.3.4 | Spaces in Python Universe | Name/Variable Space and Object space ... name/variable space are are variables for the objects| 
2.3.5 | Name/Variable Scope | Built-in variables (like print(), len()) are available in ANY .py file; Global can be referenced ONLY in the current file, Local can be referenced ONLY inside the current function - https://youtu.be/HdFujZpLFVg |
2.3.5.0.1 | Stack frame | when ever a new function is called and parameters are passed, a new stack frame is called that all the local variables | 
2.3.5.1 | variable referencing | inside out: local -> global -> built-in | 
2.3.5.2 | lifetime of local variable | A local variable only exists while the function is being executed — we call this its lifetime. When the execution of the function terminates (returns), the local variables are destroyed ... unless it is defined as Global inside the fn|
2.3.5.3 | lifetime of global variable | A global variable only exists while the .py file is being executed — we call this its lifetime. When the execution of the file terminates, the global variables are destroyed |
2.3.5.4 | Good programming tips | (1) Avoid referencing Global variables inside a fn and a local out a fn, if one has to DON'T name them the same, avoid initiating a GLOBAL variable inside a fn (2) Avoid initiaing global variables in a funtion ...if you must, make sure they have unique names like >>> `global_book_name = 'Book1'` | 
2.3.5.5 | Functional decompisition | breaking a function problems into smaller function problems |
2.3.5.5.1 | Global variable before or after defining a fn | a Global variable (including a function) can be initiated after a function is defined, but BEFORE the function is called |
2.3.3.6 | Print vs Return | Print is only for humams it does not store the computation of the function; Return is the ONLY valid way to store the computation of a fn in a global variable (since local variable can't be accessed outside) | 
2.3.3.7 | Function side effects | when function can change the values of Global variables - (1) by initialing a GLOBAL variable in function (2) by mutating a mutaing variable (list or dict) - mutation does not change the id/refernce but mutates the same object |
2.3.3.8 | Functional programming | programming that avoids functional side effects - MY PREFERRED way in python (1) create a copy inside the function by >>> `new_list_or_dict = list_or_dict_var.copy()` alternative (2) rather than the list/dict, pass a copy of the list/dict to the function while calling it >>> `var 1 = fn(list_name.copy())` or >>> `var2 = fn(dict_name.copy())` ...this leaves the onus on the function caller, the first option left it on the function creator |
2.3.3.8.3 | unpacking operator * for lists/tuples | `*iterable` unpacks all the elements of the object as standalone objects/values/variables WITHOUT any enclosure of list/tuple/dict...can be used to perfom actions on lists/tuples/strings ...>>> `list_final = [*list1 + *list2]` ...mostly used when calling functions - for a function >>> `def fn(var1, var2, var3):`, we could call the function using >>> f_name(var1, var2, var3), alternatively if we have a list/tuple with 3 elements, one could call the function using >>> `f_name(*list_name/tuple_name)` |
2.3.3.8.3 | unpacking operator ** for dictionaries | `**dict_iterable` unpacks all the elements of the dictionary as standalone objects/values/variables WITHOUT any dictionary enclosure ...dict1 = {'a': 1, 'b': c}, dict2 = {'c':3, 'd':4}, >>> `dict3 = {**dict+**dict2}`...can be used for calling functions as well | 
2.3.3.8.1 | *args and **kwargs | can be passed as parameters in a function ...advantages, when the coder ancipates the number of arguments passed to a function to change at run time ... *args and **kwargs are iterables and should be treated as tuples and dictionaries inside the function | 
2.3.3.8.2 | syntax: *args and **kwargs | >>> `def f_name(positional_var1, positional_var2, *args, **kwargs)` ... calling the function >>> f_name(positional_var1, positional_var1, args_1, args_2...args_n, kwargs_1 = val_1, kwargs_2 = val_2, kwargs_n = val_n) | 
2.3.3.8.3 | using var1, *args and **kwargs together | correct order >>> `def foo(x, y=3, *args, **kwargs):` ...default value of y can ONLY be used if there is no ambiguity, for eexample if fn is called like `foo(x) `or `foo(x, p=var1, q=var2)`, there is NO way to bypass the second optional variable to *args... if there is any variable after x, it will be assinged to y...there is no way to assgine default to y and variables to args |
2.3.3.9 | TUPLES |   |
2.3.3.10 | Python treatment of tuples | if something is not in (), {} or [], and is seperated by commas, then Python treats it as a tuple, e.g. >>> `var = a,b,c` , var is a tuple; |
2.3.3.11 | Tuple assingment | VERY powerful - tuples can save a lot of code and lines ...a,b,c = c,a,b is the best to do the assignment in one go (doing it one by one will require many temp values and many lines of codes)    |
2.3.3.12 | returning multiple things from a fn | return a,b,c,d will return 4 variables from a function that can be assinged to 4 variable when the fn is called >>> x,y,z = f(x)...where f(x) return 3 variables |
2.3.3.13 | Tuple unpakcing and assignment | >>> `z = var1,4,5,var2` ... >>>`f(*z)` (f() takes 4 arguments but *z unpacks the tuple and inputs them as arguments) |
2.3.3.13.1 | unpacking also works with lists/strings/dict | the length on the LHS and RHS should be the same ... >>> `x,y,...n = [3,4,...n]` ...for dict, the key is returned >>> `x,y,z = {11:22, 33:44, 55:66}` \n >>> `print(x)` \n 11 |
2.3.3.14 | iterating over a list of tuples | if only 1 iterator is used in the loop, only the 1st elements of the tuples will be looped over...special case is dict >>> if only 1 iterator, it is the key; to get key and value, use `dict_name.items():`  |
2.3.3.15 | converting a list of tuples into a list...>>> `list(tuple)` | only the first element of the tuples is converted to a list ...special case - dict ...eg list(dict_name) will return a list of the keys  | 
2.3.3.15 | enumerate | enumerate takes a sequence as input and return a sequence of tuples of length 2 (first element of the tuple is an integer starting at 0, second is the item) ...>>> `for idx, item in enumerate(iterable):` | 
2.3.4 | WHILE | also called indefinite loop  |
2.3.4.1 | While loops | more flexible/versatile but more complicated than for loop ...avoid if you can |
2.3.4.2 | syntax | >>> `initiator_variable = 0` \n  `while <conditional statement using the initiator variable>:` \n `code_to_do_something` \n `initiator_variable += 1` |
2.3.4.3 | drawbacks | if initiaor is not incremented, it can result in an indefinite loop ... debugging can be difficult |
2.3.4.4 | USAGE (1) Listener loops | the user input acts as the initiator variable changer | 
2.3.4.4.1 | USAGE (1.1) Sentinel Values | a loop that watches values and then decide on continuing or aborting the loop |
2.3.4.4.2 | USAGE (1.2) Validating inputs | for CAPTCHA etc |
2.3.4.5 | **break** statement | stops the execution of the next line in the loop AND jumps out of the loop |
2.3.4.5 | **continue** statement | stops the execution of the next line in the loop AND jumps to the start of the loop |
2.3.5 | FUNCTIONS - Default parameters |  `argument = 12/[]/{}/var1`, they provide default values, if no value is given to a variable at the time of function invocation|
2.3.5.5 | FUNCTIONS - Default parameters | for `def foo(function_argument = var1)` (1) var1 has to be to declared BEFORE the function is defined, (2) this value will be assigned as a defualt, irrespective the var1 changing value later |   
2.3.5.1 | Default parameters - mutable objects | when a function that has a default list/dict, is called by a function which references the defualt list, the default list's location is referenced ...which mean the new list is mutated ...any future function call will reference the mutated list ...solution make a copy of the mutable object inside the function | 
2.3.5.2.1 | positional arguments/parameters | values are assigned according to their position at the time of function declaration |
2.3.5.2 | keyword argument/parameters | keyword argumesnt explicitely assign values to formal parameters when a function is invoked, eg for `def foo(u, v=1, w=4, x, y, z=4)`, positional parameter would be `f(1,2,3,4,5,6)` OR `f(1,2,3,4,5)`, usage of k/w parameters would be `f(10,x=3, y=4, z=21)`...here Python will take the value of x as 10 (positional), x, y, z as k/w, and rest 2 as default ) |
2.3.5.3 | LAMBDA expressions/functions | syntax `lambda <args> : <return_value>` ..eg >>> `lambda x : x**2 ` ... can be assigned a name, >>> `square = lambda x: x**2` )         |
2.4.1 | SORTING - list.sort vs sorted(iterable) | `sorted(iterable)` is preferred, works on all objects (string/tuple/list/dict/classes), returns a list for all iterables, does not change the original iterable, returns the sorted list for all iterables, default is ascending, can do additional sorting based on a key | 
2.4.1.1 | Sorted(iterable) with the parameter `reverse` | >>> `sorted(iterable, reverse = True)`...since the defulat is a list with elements in ascending order, reverse=True returns a list with elements in descending order |
2.4.1.2 | Sorted(iterable) with the parameter `key` | >>> `sorted(iterable, key=lambda_fn_OR_fn_name_without_paranthesis)` ... eg >>> `sorted(iterable, key=absolute)`  OR >>> `sorted(iterable, key=lambda x: x**2)` OR >>> `sorted(iterable, key=lambda x: x if x >=0 else -x)` ...the funciton will pick each individual element do the transformation and rank then transformed elements, and display the corresponding elements |
2.4.1.3 | Sorting list of tuples - breaking ties | if sorted(tuple), then the result is a list that was sorted primarily on the 1st elements of the tuples, secondarily on the 2nd elements of the tuple, and so on...|
2.4.1.4 | Special case - sorting a list of tuples | with string being sorted in ascending order and numbers in descending order, or vice versa ... by using - in front of the numbers, eg `(-num, string)` ...this will sort the number is descending and the string is ascending order  | 
2.4.2 | Way of the Programmer - Lambda/Named function in sorting | a lambda choose one element in the list, char in the string, one key in the dict at a time, 1st element in a list of tuples.. so can be very handy, but if the there are other complications an external function can be used w/ the lambda  |
3.0.0 | **Data Collection and Processing with Python** | Course 3/5 - https://www.coursera.org/learn/data-collection-processing-python?specialization=python-3-programming | 
3.1 | Nested Data and Nested Iteration |  |
3.1.1 | reading nested lists and dictionaries | they have to be unpacked using [] repetedly ... for lists, use list_name[index_number], for dictionaries, use dict_name['key_value'] | 
3.1.1.1 | can also access/call function using [][] | if `var1= [ [fun_name1, fun_name2], [12,12], []  ]`, then `var1[0][0] ` is the same as fun_name1 and  `var1[0][0]()` is the same as fun_name1()  |
3.1.2 | JSON | stands for java script object notation; it is string format of dictionaries and lists ... at the end it is a special STRING format |
3.1.3 | converting a JSON formatted string to a python object | >>> `py_obj = json.loads(json_formatted_string)` |
3.1.3.1 | converting a python object to a JSON formatted string | >>> `json_formatted_string = json.dumps(py_object, sort_keys=True, indent =4)` ...sort_keys is optional and used to sort the keys in the dictionaty  |
3.2 | Nested Iteration | | 
3.2.1 | Way of the programmer | nest the same type of objects inside lists/dicts ...if you are given something else, use a if else statement, eg >>> if type(x) == type([]):  |
3.3 | Shallow copies vs Deep copies | Copying using [:], *1, .copy(), creates shallow copies  - ONLY copying at the highest/outermost level ...for any level inside, aliasing comes a picture - if the original list is mutated at 2nd layer, the copies are also changed  |
3.4 | Deep copies | completely independent of the original - any change in original is not reflected on the copied one | 
3.3.1 | Deep copies - way 1 | for lists that are uniform structes of nesting ... appending using nested iteration will give the result - when the child_list has no more lists inside it, shallow copying can be used |
3.3.2 | Deep copies  way 2 | >>> `new_copy = copy.deepcopy(original_object)` ...this requires the import of copy module >>>> `import copy` | 
3.3.3 | online JSON editor | https://jsoneditoronline.org/ | 
3.3.4 | Working with very complex nested python objects | use Understand...Extract (and print)...Repeat | 
3.3.4.1 | Understand/ work-on nested data structure | (1) view the complex structure in a prettier format using `print(json.dumps(object, indent =4))` (2) for dictionaries, check the keys using dict.keys(), for lists, check the length of the lists (3) convert to a JSON string (step 2) and view using https://jsoneditoronline.org |
3.3.4.2 | Extract one step a time | always print to see the results at each step |
3.3..4.3 | Repeat | understand, extract and print | 
3.3.2 | Map, Filter, Reduce | remember type(map), dir(map) and help(map) |
3.3.2.1 | Map function | takes an iterator and returns a list with the sane length after doing some transformations |
3.3.2.2 | Map syntax | map (function, iterator) ...function could be a named function or a lambda (it takes 1 input, the individual element, end returns something), eg >>> `map (lambda item: item *2, list1)` ...map DOES not return a list, it has to be converted to a list using >>> `list(map())` ... the length of the returned list is the same as the original list |
3.3.2.3 | Filter | filters a list based on a condition and return a sublist of elements meeting the condition|
3.3.2.4 | Filter syntax | filter (function, iterator) ...function could be named or lambda (taking one argument) but SHOULD return True/False based on which the sublist will be created eg >>> `filter(lambda item : item >5, list1)`......filter DOES not return a list, it has to be converted to a list using >>> `list(filter())` ... the length of the returned list is usually shorter than the original list  |
3.3.2.5 | reduce (needs `import functools`) | ...reduce the list to 1 value ... can be used for product/sum/concatenation of the entire list ... reduce(fn, list_name)...eg `import functools` \n `var1 = functools.reduce(lambda x,y: x+ y, [12,12,23,23,34,34,89])` \n `print(var1)`...  | 
3.3.3 | List Comprehensions | Pythonic way to do map and filter in one statement | 
3.3.33.1 | List syntax | `[ <do_this_with_each_element> for <element> in <list> if <condition> else <do_this>]` ... results are appended automatically to a list in the order they appear in the original list| 
3.3.33.2 | Advantages of list comprehension | compact, no need to define empty list, can do transformation, looping and condition checking in one line of code ...both map and filter functions done together, without the need to changing to list at the end | 
3.3.33 |  --- ZIP function | for pairwise operation amongst elements of lists - given two/multiple lists of equal lengths, zip creates a new list of tuples (the lenght of the new list is the same as the previous lists), the tuples have 1 element from each list respectively ... has to be changed to a list using list >>> `list ( (zip(list1, list2 ... list_n)) )` ...[  (1st_element_list1, 1st_element_list2, ...1st_element_list_n), (2nd_element_list1, 2nd_element_list2, ...2nd_element_list_n) ..... ] | 
3.3.34 | Working on the output from ZIP | since the output is a list of tuples, it can be iterated over easily ... `for x,y,z in list(zip(list1, list2,list3)):` ... can be used for list comprehension, dict comprehension, for loops, creating instances for Classes |
3.3.335 | working on the output from ZIP ...list comprehension | list comprehension can also be used ... the elements of the tuples can be added/subtracted..or transformed |
3.3.36 | Working on the output from ZIP ...dict comprehension | Dictionary comprehension can be used to create dictionary when data is coming from two diferent lists and there is a positional corelation between the data >>> `dict1 = { x:y for x,y in list_of_tuples_of_length_2}` |
3.3.1 |  --- Internet APIs  ---  | |
3.3.1.1 | Using REST | REST = REpresentational State Transfer = website that take inputs in the form of python dictionay (key, value pairs) and return an output as a text string  | 
3.3.1.2 | API | Application Programming Interface - speficies how an external program (an application program) can request that a program perform certain computations |
3.3.1.3 | REST APIs | specifies how client program can call a REST website using APIs to get information | 
3.3.1.4 | module required - requests and json |   |
3.3.1.5 | URL Structue for REST APIs | 3 parts of the URL (1) the endpoint_URL (2)the question mark: (3) the query (key/value pair(s) seperated by a &), for example: https://www.google.com/search?q=linkedin (1) https://www.google.com/search  (2) ? (3) q=linkedin .... or https://www.linkedin.com/search/results/all/?keywords=google&origin=GLOBAL_SEARCH_HEADER (1) https://www.linkedin.com/search/results/all/  (2) ?  (3) keywords=google&origin=GLOBAL_SEARCH_HEADER  | 
3.3.1.5 | -- Calling APIs and getting information -- | >>> `page_response = requests.get(endpoint_URL, params = params_dict)` \n `page_py_object = page_response.json()` ...params_dict is a dictionary of parameters like >>> `params_dict = {`KEY`: `my_API_key`, 'keywords': 'google', 'origin': 'GLOBAL_SEARCH_HEADER'}` | 
3.3.2 | How to use a REST API | answer these Q... (1) Is as authentication required to access the API, if yes how to authenticate yourself (2) what is the endpoint_URL (3) what is the query_param_dict (keys and values) that you need to pass to params (4) check the URL that was formed after adding the query_param_dict (5) what is structure of data that is returned by the API, how can you extract what you want ...for this, convert the python object to a JSON string (>>> `json.dumps(py_object, indent=4)`) and print and/or view in https://jsoneditoronline.org  | 
3.3.3 | Caching - intro | this allows the program to fetch the results locally rather than getting it from the server/page ...increases speed, decreases API calls, works even if the host page is down | 
3.3.4 | Caching - syntax | `import requests_cache` (newline) `requests_cache.install_cache('cache_name')` ...this will create a 'cache cache_name.sqlite' at the same level as the file with no expiration time set ... NOTE - the import_requests module is not native to python, so one might need go to `win cmd -> pip3 install requests_cache` |
3.3.5 | checking if a page was found in cache | `print(page_respose.from_cache)` .. this return True if the page_response = requests.get(base_url, params=params1)) was found/pulled in/from the cache | 
3.3.5 | Cache retrieval: imporving efficiency | since dictionaries are not ordered, and we are passing a dict as a parameter to make an API call, different API calls might be requesting the same page (with params reordered) ...solution ordering the parameters dict ... `params_ordered = sorted(list(params_dict, key= lambda dict_key : params_dict[dict_key]))`  |
3.3.6 | opening a page in browser - syntax | `import webbrowser` (newline) `webbrowser.open(<url_to_be_opened>)` ...crete a URL by appending string to an endpoint URL |
4.0 | **Python Classes and Inheritance** | https://www.coursera.org/learn/python-classes-inheritance?specialization=python-3-programming |
4.1 | Object Oriented Programming (OOP) | *** use objects, that contain both data and functions | 
4.1.2 | Objects in Python ? | In Python, every value is an object. integer, string, float, list, dicts, tuples, functions...objects have attributes/state (What is the position/id/color/shape) and methods/functions (what can it it do))...each object is stored in an instance variable..for example, the different turtles are instances of turtles ... or different players in a game ... or different cars in a game (they have attributes - names/colors/value; they have methods to do something - turn left/right, do tail up/dows, go forward/backward, leave prints) ) ....similarly different lists are instances of the `list` class | 
4.1.3 | class syntax | >> `class Class_name():` ...the convention is to have the Class name start with upper case, e.g. Point, School, Country | 
4.1.3.1 | instance of a class | called instantiating ... >>> `instance_name = Class_name()` | 
4.1.3.2 | referring to instance variables and instance methods from inside a class | >>> `self.instance_variable`   >>> `self.method_name()` |
4.1.4 | methods of a class | >>> `def method_name (self)` ...similar to functions in ways that they can take arguments, do things, and return objects ... difference, (1) they belong to the class ...outside the class, are always called/invoked using an instance e.g. >>> `instance_name.method_name()` (2) the minimum number of arguments when declared must be 1 (i.e. self), self points to the instance that is calling the method, this means when calling a method one less argument is taken, the 'self' is understood ... so a >>> `def method_name(self, x,y,z)` will be called like >>> `instance_name.method(x,y,z)` as the instance_name replaces self...example >>> `list_name.append(7)` is actually calling the method >>> `def append(self, 7)` in the class list of which list_name is an instance |
4.1.5 | constructor | special method used to either (1) give default values to instance variables, or (2) accept values at the time of instantiation for instance variables |
4.1.6 | constructor ... syntax | >>> `def __init__ (self, parameter(s)):` \n `self.x = x` \n `self.y=y` ...__, two underscores is also called dunderscore | 
4.2.1 | instances can be stored in a list | instances (being objects) can be stored in a list, and referenced using >>> `list_name[index]` , e.g. list1 = [instance1, instance2, instance3, ... instance_n ...to reference instance1 >>> `list1[0]  `... which means we can use list operations append, del, pop, list comprehension, sorted() zip(), for loops on list of instances| 
4.2.2 | creating instances from data | `for` loops (also list/dict comprehension) can be used for instantiation .... iterator could be string, tuple, range, dict, or list ( of numbers, strings, lists, dict, tuples generated using zip(a,b,c ...)  ) in which case a,b,c can be passed to the constructor |
4.2.3 | instances can be passed as arguments to functions and methods | ...eg, a method >>> `def method _name(self, instance2)` will be called as >>> `instance1.method_name(instance2)` ...PLEASE note: while calling, the instance before the method will automatically be passed as 'self'| 
4.2.3.1 | special methods | constructor (def __init__ (self,...) ) | 
4.2.3.2 | __str__ | `def __str__ (self):` \n  `return <how to represent the instance as a string>` ...WHY use it? for legibility.. print(instance1) only tells that the object is an instance of a class, __str__ allows for more human-readable information | 
4.2.3.3 | __add__ | `def __add__ (self, instance_name):` \n `return self.variable_name + instance_name.variable_name` ...calling the method >>> `print(instance1 + instance2)`| 
4.2.3.3 | __sub__ | `def __sub__ (self, instance_name):` \n `return self.variable_name - instance_name.variable_name` ...calling the method >>> `print(instance1 - instance2)`| 
4.2.3.1 | methods can return new instances | >>> def new_instance (self, other_instance): return Class_name(self.variable1 + other_instance.variable1 + 45) ... calling the method >>> `instance_new = instance.new_instance(other_instance)` .... here the method new_instance returns a new instance which is getting stored in instance_new | 
4.2.3.2 | Sorting list of instances | >>> `sorted_instance_list = sorted(list_of_instances, key=lambda self: self.<instance_variable_name> )`   ...the list of instances can be created using list comprehension, zip(list, list2), or other list methods ...since the result will be displayed as addresses, for proper display, vaiarables will need to be retrieved using `list comprehension` or `for` loop ...eg >>> `print[instance.variable1 for instance in sorted(list_of_instance1, key=lambda instance: instance.variable1 ] `|
4.2.3.3 | Class Variables | Class variables are declared in the class, they have the same value for all the instances of the class ...declared NOT using self, eg >>> `var1 = 10` ...as seen earlier, instance variables/methods always have self attached to them eg, >>> `self.instance_var = 20` or >>> `def instance_method(self, ...)` ....accessed using >>> `instance_name.class_variable_name` | 
4.2.3.4 | Class Variables and instance variables | way to tell apart - at the time of initiation, class variable will not have self associated with it, instance variable will have that ... precedence, if they have the same name, the instance variable overrides the class variable |
4.2.1 | ----- CLASS INHERITENCE ----- | Why? makes for readability, code resue, easier debugging ... allows us to retain everything from the super class, while only mentioning the differences in the sub-class |
4.2.2 | syntax | >>> `class Sub_class_name (Super_class_name):` \n `pass` ...this will inherit all the variables and methods of the super class |
4.2.3 | Howe does the PY attributor look up attributes names | (1) determine if it is a method or an attribute... a method will have a parenthesis while an attribute will not ....if it is an attribute (2) look up the name in instance variables, if found use it, if not (3) look up in class variables, if found use it, else (4) go to the parent class and lookup in instance variables and then class variables  ...repeat the process till attribute found or last ancestor looked up ...if still not found, return an error | 
4.2.4 | looking up methods | if methods have the same name in a sub-class and the super class, the sub-class methods are called, not the super-class's | 
4.2.5 | invoking the parent class's method | WHY ? (1) you want to use a method from the super class (it has important and long code) and (2) you want to make modifications to it and (3) you want to retain the name ...most commonly in the case of a constuctor __init__ |
4.2.6 | invoking a parent class's method (SINGLE parent) - syntax | >>>`super().<method_name>(variable(s))` ... the code goes after the declaration of the method of the subclass ...most commom usage: constructor ...eg. >>> `def __init__ (self, parent_var1, parent_var2,... subclass_var1, subclass_var1,...):` \n `super().__init__(parent_var1, parent_var1,...)` \n `self.subclass_var1 = subclass_var1` | 
4.2.6.1 | invoking a parent class's method (**MULTIPLE parents**) - syntax | >>>`Parent1.<method_name>(self, all_parent_arguments)` \n `Parent2.<method_name>(self, all_parent_arguments)`... the code goes after the declaration of the method of the subclass ...most commom usage: constructor ...eg. >>> `def __init__ (self, parent1_var1, parent1_var2... parent2_var1, parent2_var2... subclass_var1, subclass_var2,...):` \n `Parent1.__init__(self, parent1_var1, parent1_var2,...)` \n `Parent2.__init__(self, parent2_var1, parent2_var2...)` \n `self.subclass_var1 = subclass_var1` | 
4.3 | TESTING in python |  | 
2.44 | 3 types of programming error types | Syntax errors, runtime errors/exception, symantic errors | 
2.44.1 | syntax error | An error in a program that makes it impossible to parse — and therefore impossible to interpret. | 
2.44.2 | runtime error or exception | An error that does not occur until the program has started to execute but that prevents the program from continuing. | 
2.44.3 | semantic error | An error in a program that makes it do something other than what the programmer intended. |
4.3 | try/except | the try/except block is a very helpful code, that allows a program to stop the block of code when an exception(run time error) is ecountered, and then jump to the `except` block of code ...this will allow the program to work | 
4.3.1 | try: except parameters | `try:` \n `<block of code>` \n `except Exception as e:` \n `print(e)` \n `<block of code>`  | 
4.3.1 | assert statement | >>> `assert <code1> == <code2> ` ...it checks code1 against code2, in case they are same, does nothing, else return a runtime error | 
4.3.2 | module unittest...CONFUSING, BETTER ALTERNATIVE is pytest (below) | `import unittest` is the main module in python for testing | 
4.3.2.1 | unittest syntax ...CONFUSING, BETTER ALTERNATIVE is pytest (below) | a testcase is created by subclassing `unittest.TestCase`. Inside the class the individual tests need to defined as methods, the method name must start with the letters `test_`. To choose the type of test, a call need to be made to a function in `dir(TestCase)`, eg `assertEqual()`, finally, the tests are run with the code `unittest.main()` ...`class Class_name(unittest.TestCase):` \n `def test_method_name(self):` \n `self.assertTrue(fn, value)` ...to run the tests >>> `unittest.main()` NOTE: assertTrue will compare the return value of the function againt the next argument...no code will be run after unittest.main() |
4.3.2.2 | pytest | EASIER than unittest...not native to python, install from the command prompt >>> pip install pytest ...https://runestone.academy/runestone/books/published/thinkcspy/UnitTesting/TestingWithpytest.html#organizing-pytest-functions | 
4.3.3.3 | pytest - cleaner alternative to unittest | uses easy `assert` statements, we can have testing a part of the program, all tests should be as functions starting with 'test_', good idea to have `test_<name_of_function_being_tested>` | 
4.2.3.4 | running pytest | >>> `pytest <name_of_the_python_file>`, this will run all the functions starting with `test_` ... this allows a coder to run and test his code easily ... `python file_name.py` to run and `pytest file_name.py` to test | 
MISC | types to tests | `return test`, `side-effect test`, `edge-case test` ...`return test` checks if a function is returning the desired value, a `side-effect test` checks if a function is mutating a list/dictionary as planned.| 
5.0 | Python Project: pillow, tesseract, and opencv | https://www.coursera.org/learn/python-project?specialization=python-3-programming | 
5.1 | PIL | Python Imaging Library - to manipulate images - increase brightness, change colr, create contact sheets | 
5.2 | pytesseract | OCR - optical character recognition ...reading English from images | 
5.3 | cv2 | open cv - detect faces in an image | 
MISC.1 | __name__ and '__main__' | the file runnign the code gets the value of '__main__' for the variable __name__ ... this can be used to made sure that the code of the current file is getting executed ... eg, >>> `if __name__ == '__main__':` \n `<main program ---- variables, function_calls, instantiation>` ...NOTE, it is like any other if statement, the codes after the statement and above are exexuted normally. |
MISC.2 | DECORATORS | https://www.youtube.com/watch?v=r7Dtus7N4pI https://www.youtube.com/watch?v=FsAPt_9Bf3U  https://www.youtube.com/watch?v=FsAPt_9Bf3U | 
MISC.2.1 | syntax for decorator function | `def decorator_function(fn_to_be_decorated):` \n `def wrapper(*args, **kwargs):` \n `<some code>` \n `return fn_to_be_decorated(*args, **kwargs)` \n `<some code>` \n `return wrapper` (same indentation as def wrapper) ...`@decorator_function` \n `def fn_to_be_decorated(*args, **kwargs):` \n `code` \n `return <something>`...calling decorator >>> `fn_to_be_decorated(a,b,c,d, a="pepsi, b='coca_cola)` ....this is the same as `decorator_function(fn_to_be_decorated(a,b,c,d, a="pepsi, b='coca_cola))` |
MISC.2.3 | syntax for decorator class | `class decorator_class(object):` \n `def__init__(self, fn_to_be_decorated):` \n `self.fn_to_be_decorated = fn_to_be_decorated` ....`def __call__(self, *args, **kwargs):` \n `code_here` \n `return self.fn_to_be_decorated(*args, **kwargs)` ...write the fn_to_be_decorated as above, call the same way |
MISC.2.4 | use case of DECORATORS | logging ...timing how long something ran ... | 
MISC.2.5 | decorators can be stacked | @decorator_fn1 \n @decorator_fn2 \n @decorator_fn3 \n def function_to_be_decoreated() ...it is the same as >>> `decorator_fn1(decorator_fn2)(decorator_fn3)(function_to_be_decoreated()` |
MISC.2.5 | ***COREY SCHAFER on PYTHON CLASSES*** | https://www.youtube.com/watch?v=ZDa-Z5JzLYM&list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc | 
MISC.2.5.1 | Corey - Python Class | class methods and static methods use decorators ... have specific use cases |
MISC.3 | Generators | https://www.youtube.com/watch?v=bD05uGo_sVI | 
MISC.4 | Sorting algos in Python | https://medium.com/@george.seif94/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889 https://stackabuse.com/sorting-algorithms-in-python/ https://www.tutorialspoint.com/python_data_structure/python_sorting_algorithms.htm |

</details>  

---

### PYTHON COURSE 2 and 3 - KAGGLE, UOFT BOOTCAMP
<details>
<summary>Click to Expand/Collapse</summary>

- Kaggle Course URL: https://www.kaggle.com/learn/overview
- UofT Course URL: https://bootcamp.learn.utoronto.ca/data/

Number | Topic | Comments | Misc
|---|---|---|--- |
0.0 | Python Interview | https://www.youtube.com/watch?v=DEwgZNC-KyE&t=67s | 
0.o.1 | checking the id of an object | >>> `id(object)` | 
0.0.1 | Debugging | look for the line number and the type of error, comment out that line and run the program, if the issue goes away, it was on that line, if it is new error, than fix the line above it, or worst case - comment the error line and all lines below it and run |
1 | Checking the version of Python in Windows | windows cmd -> `python --version` |
1.1 | Running a python file | windows cmd -> cd to the root where file is placed >>> `python <filename>` OR if coding on VS code, open the file in the integrted terminal, check the terminal should be cmd, and run the file >>> `python <file_name>` |
1.2 | Opening a .pynb file in D: | open ***Anaconda Prompt (PythonData)*** or ***Anaconda Prompt (mlenv)***. On the default c prompt, press d: >>> `(PythonData) C:\Users\user_name>D: ` then >>> `(PythonData) D:\> jupyter notebook` ...this will open the files in D:, open the desired file |
1.2.1 | Data types | integers, floats, strings, booleans ....checking the data types >>> type(2) >>>type(12.23)  >>> type('Star') >>> type(True) | 
1.3 | naming convention of variables | can consist of uppercase, lowercase, digits and underscore - lower case is preferred. Must be in snake case, sample_variable...no keywords to be used, list of keywords >>> `help('keywords')`|
1.4 | file types | text file (can be open in a text editor like notepad, excel)...binary files are written in binary code (power of 2) thus cannot be read with a text editor.
**2** | **Kaggle Course - 1/18** | **Python - https://www.kaggle.com/learn/python** |
2.1 | loading the file in python (w/o Pandas)| opening the location of a file ...>>> `import csv` (nextline) >>> `with open(file_path) as data_file:` (nextline) `print(data_file)` |
2.1.1 | reading a file in python (w/o pandas) | opening the data in a csv file >>> `import csv` (nextline) >>> `with open(file_path) as data_file:` (nextline) >>>`data_file_name = csv.reader(data_file)` (nextline) .....iterating over all the rows >>> `for row in data_file_name: (nextline) print(row)` |
2.2 | writing the header of a csv file (w/o Pandas) | >>>`data_file_name = csv.reader(data_file)` (nextline) >>> `headers = next(data_file_name)` (nextline) >>> `print(headers)` ...this also skips the header, we can then iterate through the rows using >>> `for row in data_file_name:` (nextline) 'do something | 
2.3 | writing to a file in python (without Pandas) | >>> `import csv` (newline) >>> `with open('path_of_file_to_save', 'w') as text_file:` (newline) >>> `text_file.write("Hello World")` |
2.4| 3 VERY important functions in python | >>> `type()` (what's type is this object?), >>> `dir()` (what can I do with it) >>> `help()` (tell me more about it) |
2.4.1 | print in python | print(x), help(print), print(x, end =' ' ) |
2.4.2 | writing in multiple lines | >>> `print(f'{value}' <new_line> f'{value}' <new_line> f'{value}')` | 
2.4.3 | formatting numbers using f-string f'' | >>> `f'{value:,.2f}'` e.g. >>> `f'{23232232.2323232:,.2f}' ....this will have a thousand comma seperator and 2 digits after decimals |
2.4.4 | formatting numbers using .format(), can also be used to format complete columns using .map | >>> `'{:,.2f} text {:,.2f}  text {:,.2f} ...{:,.2f} '.format(value1, value2, value3,...value_n)` ...advantage over f-string, it can be chained with functions like , >>> `map('{:,.2f}'.format)` | 
2.5 | operators | +, -, *, /, % (Mod/Modulus/Reminder, e.g. 11 % 3 = 2), // (Floor Division/Quotient, e.g. 11 // 3 = 3, same result as int(11/3)), ** (Exponent, e.g 2**3 = 8) |
2.6 | PEMDAS | Parentheses, Exponent, Multiplication, Division, Addition, Subtraction |
2.7 | Python built-in function | min(1,5,6,7,8) , max(1,2,4,65), abs(-34) |
2.9 | Convert to int, float, str, bool | x = int('223') OR float(10) OR str(10) OR bool(10)...for bool, only the number 0 is False, for strings only empty string is False (even a whitespace is TRUE)...check the outpur using type(x) |
2.10 | help with a function | help(function_name), eg `help(print)` |
2.11.0 | defining a function | def <function_name>(parameters): code_text return <value_to_be_returned> |
2.11.1 | return | it will break out of the current function, can be used to return if all other options have been exausted wihtout any outcome |
2.12 | : and indentation | very important in python |
2.13 | commenting a line | # |
2.14 | ***Docstrings*** Good Programming practice | It is a triple-quoted string (can span multiple lines) and it comes right below after a function/class has been declared. When we call help() on that function, it shows the docstring. eg  `""" This is a description of the function above >>> """` |
2.14.1 | doctstring ... | example: def fn_name(param1, param2): \n ''' Modifies a list... \n :param param1: A list \n :param param2: a dict \n :return x: modified list \n >>> example of implementation \n result \n ''' | 
2.15 | Higher order functions | functions that operate inside other functions |
2.16 | 'pass' is a placeholder code  | it can be used inside a function when there is no code, when only the function name is known and zero code has been written  def function_name(): pass |
2.17 | rounding a float | round (number, ndigits) ... default digits = 0, if it is postitive it will round number after the decimal >>> `round(1222123.123345, 2)` -> 1222123.12 ... if it is negative, it will round to 10, 100, 1000 >>> `round(1222123.123345, -2)` -> 1222100 |
2.18 | having a default argument in a function | `def function_name(x, y=3):` ...  |
2.19.0 | Boolean types | True or False |
2.19.1 | Boolean operators | ==, !=, <=, >=, <, >  |
2.19.2 | Boolean expression | `and`, `or`, `not` |
2.19.3 | Membership operators | `in` and `not in`  | 
2.19.3.1 | Treatment of numbers and strings as Booleans | only 0 or 0.0 are treated as False, everything else is True....only '' is treated as False, everything else is treated as True |
2.19.4 | Boolean operator precedence | in the absence of a parenthesis,`and` is evaluated before `or` |
2.19.5 | Combining Boolean operators | True and True = True, True and False = False, True or True = True, True or False = True |
2.20 | Conditionals | if <boolean_conditional>:, elif <boolean_conditional>:, else: ...used with Boolean operators/expression/membership operators|
2.22 | Lists - help(list) | Lists are ordered sequences of values, they are mutable (length and values can be changed). Items in the list can be numbers, strings, lists, variables, or a combination, when no elements are mentioned, it is a empty list ... list[0] is also called list[sub 0] |
2.22.1 | List - Indexing | indexing starts at zero, so the first element is [0]...indexing ends at -1 so the last element is [-1] ... the list can be accessed in many ways from [0, ..., -1] |
2.22.2 | List - Slicing, the sliced list is treated as a list | First n elements = list_name[:n], last n elements = list_name[-n:], all elements = list_name[:] Or list_name....when calling list[m:n], it starts from the element at index m...to the element at index (n-1)...just like in range(2,20), so list[4:7] will show elements at index 4 to index 6 = 3 elements |
2.22.3 | List - adding /changing values | simple reassignment, >>> `list[n] = <value>` ... multiple values at one time >>> `list[:5] = [a,b,c,d,e]` |
2.22.4 | List - Finding Lenght | len(list_name) |
2.22.5 | List - Sorting a list in ascending order | sorted(list_name) |
2.22.6 | List - Sum, Min, Max | sum(list), min(list), max(list)
2.22.7 | List - adding 1 element to the end of the list | >>> `list.append(<value>)` |
2.22.7.1 | List - removing the last element of the list | >>> `list.pop()`  |
2.22.7.2 | List - adding item at a specific index | >>> `list.insert(index, value)` | 
2.22.7.3 | List - Deleting an item from a specific index | >>> `list.pop(index)` | 
2.22.7.4 | List - Checking if an item is present in a list | returns True or False >>> `element in <list>`
2.22.7.5 | List - removing the first instance of a value | `list.remove(value)` |
2.22.7.6 | List - returing index of the first occurane of an element in list | `<list_name>.index(<element>)` |
2.23 | Tuples - help(tuple) | Tuples are just like lists. Difference - created using () OR without any opening/clsing brackets AND at least 2 elements - e.g. `<tuple> = <element1>, <element2>` , and are immutable. HOWEVER - The lists inside the tuples are mutable. |
2.23.1 | Tuples - often used for functions that have multiple return values | many functions that return multiple values return the results in the form of tuples...for example, the >>>`<float>.as_integer_ratio()` returns 2 values as tuples; the returned values (a numerator and a denominator) can be assigned to a tuple, eg >>> `numerator, denominator  = <float_number>.as_integer_ratio()` ... same principal is used for swapping 2 variables  >>> `a = 1` (newline) `b= 0` (newline) `a,b = b,a` (newline) `print(a,b)` |
2.23.2 | Tuples - more | initiation >>> `new_tuple =( )`...finding the length >>> `len(<tuple_name>)`...applying indexing operator >>> `tuple[1]`...applying slicing >>> `tuple[:4]`
2.33 | **Loops** | to repeteatedly execute some code |
2.33.1 | for loop | can be used to loop over list, tuple, strings (a string is treated as a tuple) |
2.33.2 | range () | A very important function similar to `for (i, i<10, i++)` in C++. This allows for the code to run for a required number of times. `for i in range(10):` ... also comes in handy as you can have the range equal to the length of a list >>> range(len(list/tuple/dictionary)).. the default start index is 0, but it can by anything else >>> `range(index_start, index_end_plus_one)` |
2.33.3 | while loop | you have to (1) initiate the iterator b4 the loop (2) increase the iterator in the loop...e.g.>>> `i = 0 (newline) while i <20: (newline) do_something (newline) i += 1`  |
2.33.4 | List comprehensions - special loops for lists | works only for `for` loops...NOT with the `while` loop..can use `if` conditionals after for: `list = [<do_this> for <this> if <this>]`, after it is run, it returns the list as well |
2.34 | **Strings** | ...can be used with single or double quotes...if you are using one of the 2 in the string, use the other to encapsulate the string. >>> `print("Canada's capital is Ottawa")` >>> `print('He said "I am excited !"')` |
2.34.1 | String - methods | They can be indexed `'Example'[0]`, sliced `'Example'[:3]`, checked for length `len('Example')`, looped over >>>`for alphabet in 'Example':`, can be used for list comprehension `[alphabet for alphabet in 'Example' if alphabet in ['a','e','i','o','u']]`...like tuples (and unlike lists) they are immutable, PROOF `'Example' == ('Example')` |
2.34.2 | The escape character `\` | >>> `print('He said \"Canada\'s capital is Ottawa\"')` |
2.34.2.1 | Escape character usage | `\' `single quote. `\"` double quote, `\\` backslash, `\n` newline
2.35 | \n newline | added by default in print statement, can be changed >>> `print(<example>, end=' ')` - this will leave just one whitespace between the printed values, unlike the default newline |
2.36 | triple quotes | `'''...'''` or  `""" ... """  ` ... allows to write a string of any length without worrying about lines |
2.37 | String methods | Change to all upper case >>>`<string>.upper()` ...Change to all lowercase >>>`'<string>.lower()` | 
2.37.1 | Other string methods | check the length >>> `len(<string>)` , checking the index of the first occurance of a character >>>`'sentence_to_find_the_character_in'.index('the_character')` also check the 1st occurance of a string`'Example'.index('mple')`, check if the string starts with something `'sentence_to_find_the_character_in'.startswith('string')`, check if the string ends with something `'Example'.endswith('Exa')` | misc
2.37.2 | misc | to check if a char is upper/lower case >>>`'P'.isupper()` |
2.37.3 | swap the case of a string | >>> `<string>.swapcase() ` |
2.37.4 | String - converting a string to a list of independent characters | >>> `list(<string>)` |
2.37.5 | Going between strings and smaller sub strings: **split()** and **join()** | `Split()` is used to split a string into a list, the default point of splitting is a whitespace, other points can be specified - it returns a list of strings (which can be assigned to variables) >>>`e1, e2, e3 = 'Example is here'.split()` or `mm, dd, yy = '1/10/2021'.split('/')`. `join() `is used to join a list of strings into a string, the splitting point has to be mentioned ... >>> `'<new_seperator>.join([string1, string2, string3])` |
2.37.6 | concatenate strings using + | you can add multiple strings into 1 string using >>> `Test1 = 'Example' + ' 23232'`. NOTE - any non string object has to be changed to a string using `str()`  |
2.37.7 | f'string {} ..... ' | can be used to create/ print a string with a varible |
2.37.8 | formattting inside strings | `{<value>:,}` will add a comma seperator... >>>`{<value>:2f}` will give the output rounded to 2 decimals... >>> `{<value>:-2f}` will round to tens/thousands
2.38 | **Dictionaries** | starts and ends in {}, keys and values....and items (key/value pair) ... help(dict) |
2.38.0.1 | 3 rules - 1/3 | (1) keys have to be unique |
2.38.0.2 | 2/3 | (2) keys can ONLY be immutable objects - int/str/float/tuple, but cannot be list/dict |
2.38.0.3 | 3/3 | (3) values can be objects of any type - int/float/str/list/dict/tuple |
2.38.1 | creating dict | >>> `dict1 = {}` or >>> `dict1 = {'key1':value1,'key2':value2, 'key3':value3, 'key4':value4, 'key5':value5}`  |
2.38.1.1 | returning all keys, values and itesms of the dictionary | >>>`<dictionary>.keys() ` >>> `<dictionary>.values()` >>> `<dictionary>.items()` ...output as `dict_keys(['AA', 'BB', 'CC'])`  |
2.38.2 | accesssing a value using key | >>> `dict1['key1']` ... OR >>> `dict1.get('key1')`  |  
2.38.3 | changing value using key >>> `dict1['key1'] = 44` |
2.38.4 | adding new items to a dictionary | >>> `<dict_name>[<new_unique_key>] = value` ... if the key is already present, it will overwrite it| 
2.38.5 | other methods | getting the length >>> `len(<dict_name>)`
2.38.6 | Dictionary comprehension | similar to list comprehension, >>> `new_dict = {i:i**3 for i in range(20)}` |
2.38.7 | using `in` to check for a key in a dict, cannot check for values | `<key> in <dictionary>`, this will return True or False |
2.39 | looping over keys | for loop (by default) loops over only the keys >>> `for i in dict:` ...explicit looping >>> `for i in dict.keys()` |
2.39.1 | looping over values | >>> `for i in dict.values():` |
2.39.2 | looping over keys and values | >>> `for i,j in dict.items():` ... it will return keys, and j will return corresponding values|
2.39.3 | removing an iem | `<dictionary>.pop(<key>)`....eg >>> `dictionary.pop('Name')` |
2.40 | ***Working w/ external libraries*** | way to access them >>> `import pandas`, get help on the libraries: >>> `help(pandas)` , checking all the directories >>> `dir(pandas)`,type >>> `type(dir)` |
2.40.1 | shorten form of an external library | >>> `import pandas as pd`, >>> `import numpy as np` >>> `import tensorflor as tf` |
2.40.2 | Calling variables in a library by it name only | this CAN make life easier >>> `from math import *` >>> `pi` >>> `3.141592653589793`  (this is easier than writing >>> `math.pi` >>> `3.141592653589793`) ... this can ALSO cause bugs which are difficult to detect and fix (especially if you are calling all variables from multiple libraries and they have the same function doing different things), solution (1) call only the methods that you want from a library >>> `from math import log, pi` >>> `from numpy import asarray` (2) use full forms, this will make the code easier to understand and debug |
2.40.3 | accessing submodules | to be accessed by multiple dots, eg. >>> `numpy.random.randint()` |
2.40.4 | While working with external libraries, the 3 most important functions in Python | >>> `type()` >>> `dir() `>>> `help()` |
2.40.5 | Operator overloading | Each library can define its own working with objects. When we do `dir(pandas)`, the methods that have 2 underscores at the start and at the end, e.g. `__getattr__`  are related to operator overloading. |
2.41 | Miscellanous | Miscellanous | 
2.41.1 | ***lambda function*** | is short anonymous functon that can any number of arguments - saves time and effort, syntax >>> `lambda argument_list : expression` ...eg, >>> `lambda x: x*9/5+32` ...this funciton will take `x` as the argument and return x*9/5+32 |
2.41.1.1 | Lambda - w/ a name | like other functions, it has to be called, it can be given a name >>> `my_fn = lambda x:x**3` (newline) >>> `variable = my_fn(5)` | 
2.41.1.2 | Lambda - w/o a name| can be called w/o a name inside another function like map, eg >>> `list(map((lambda x: x**3), [i for i in range(20)]))` |  
2.41.2 | **List of Dictionaries** | is like a 2D table with the keys as the columns and the values as the rows >>> `list_of_dict = [{'Country': 'Canada', 'Capital': 'Ottawa'}, {'Country': 'India', 'Capital': 'New Delhi'}, {'Country': 'USA', 'Capital': 'Washington'}]` |
2.41.3 | List of dictionary - methods | All list methods (len, indexing, slicing, append(), insert(), remove()) can be used to access data...various dictionary methods can also be used in combination with the list methods |
2.41.4 | all permutations of x,y,z using list comprehension | >>> `list2 = [[x,y,z] for x in range(5) for y in range(6) for z in range(8) ]` | 
2.41.5 | converting single line array input into a list | >>> `A = [int(x) for x in input().split()]` | 
2.41.6 | converting a string to a list of words | >>> `new_string = <string>.split(" ")` ... joining strings into 1 string >>> `final_string = '-'.join(<old list of string>)` |
2.41.7 | checking if a string is numeric | >>> `<string>.isnumeric()`
2.41.8 | max can be used with a key | >>> max(iterable, key=) ...it will return the element with the max value after the calculation | 
2.41.8.1 | checking for maximum in a dictionary | finding the maximum key >>> `max(dictionary_name)` ... finding the key with the max value >>> `max(dictionary_name, key=dictionary_name.get)`
2.42 | **Python and Object Oriented Programming** | Everything in python is an object, objects carry some things aroud with them, this 'thing' can be accessed using the dot syntax
2.42.1 | Attributes - non-function things attached to an object | eg, numbers in python have a imaginary part, which can be accessed using `print(<number>.imag)` e.g. >>> `print(4.imag)`, the imaginary part of real numbers is 0. Creating an imaginary number >>> `c = 12 + 3j`   (the key is j, nothing else will work), printing the imaginary part of c, >>> `print(c.imag)` |
2.42.2 | Methods - Functions attached to an Object are called  | if you want to access a function, use `<object>.<method>`, eg >>> `4.bit_length`...in order to call the function, use the paranthesis, eg >>> `4.bit_length()` |
2.43 | ***Python 3 specializaion - Coursera*** | https://www.coursera.org/specializations/python-3-programming | 
2.44 | 3 types of programming error types | Syntax errors, runtime errors/exception, symantic errors | 
2.44.1 | syntax error | An error in a program that makes it impossible to parse — and therefore impossible to interpret. | 
2.44.2 | runtime error or exception | An error that does not occur until the program has started to execute but that prevents the program from continuing. | 
2.44.3 | semantic error | An error in a program that makes it do something other than what the programmer intended. |
2.44.4 | values and value types | int = integer, float = floating point number, strings ...to find the type >>> type(23) >>> type('Hello World) >>> type(3.14) |
2.44.5 | strings can be enclosed in | single quotes OR double quotes OR three single/double quotes ...triple quotes strings can span multiple lines | 
2.44.6 | Type conversion functions | str(), float(), int(), list() | 
2.44.6.1 | common usage of str conversion str() | in print statement to print integers >>>`print('this is the result' + str(10) + 'and then ..')`
2.45 | operators and operands | Operators are + - * / (division) % (modulus/reminder/integer reminder) // (int division OR truncated div operator; does not round) ** (exponentiation) ...// also works for floats, it returns a float |
2.45.1 | % (mod/moudulus) operator uses | to check divisibility if a num% other_number ==0, then it is divisible, cheking even odd, if num % 2 == 0 even else odd, extracting the right most digits from a number, eg 1 right-most digit, do num%10, 2 right most digits num%100 | 
2.46 | order of operands | evaluated left to right (exception exponents...2**3**2 = 2**9 NOT 8**2)....Parenthesis, Exponentiation, Multication, Division, Addiiton and Subtraction - PEMDAS |
2.47 | reassignment | python variables can be reassigned | data1 = 12, data1 = 13 |
2.48 | updating a variable | x = x+1, x += 1, incremening/decrementing...bumping is increasing by 1 | 
2.49 | concatenating and repeating - strings, lists, tuples | concatenating using + >>> `new_string/list/tuple = string1/list1/tuple1 + string2/list2/tuple2` ...repetition using * >>> `new_string/list/tuple = string/list/tuple*5`
2.50 | .count() with string, list, tuple | counts the number of occurance in a string or list... >>> `string.count('alphabet(s)')` ... >>> `list.count(element)` ... >>> `tuple.count(element)`|
2.50 | .index() with string, list, tuple | returns the index of the 1st occurance in a string or list... >>> `string.index('alphabet(s)')` ... >>> `list.index(element)` ... >>> `tuple.index(element)` |  
2.51 | using .split() to split a string into a list | >>> `string.split('split at')`...the default split is a whitespace, but it can be any character or combination of characters, like / - a ab in , : | 
2.51.1 | using .join() to join a list into a string | >>> `'join with'.join(list)`...eg. '-'.join('Feb 12 2019') | 
2.52 | ***LIST METHODS*** | |
2.52.1 | LIST - adding a element at the end of the list | >>> `list1.append(value)`
2.52.2 | LIST - adding an element at an index | >>> `list1.insert(<index>, value)` |
2.53.3 | LIST - adding multiple items at an index | ... >>> `list1[0:0] = [element1, elment2, elementn]` ... | 
2.53.4 | LIST - deleting the last element | >>> list1.pop() |
2.53.4.1 | LIST - using POP to return element at an index | >>> `list.pop(3)` |
2.53.5 | LIST - deleting elements using index | ...deleting 1 element >>> `del list1[5]` ... deleting multiple elements >>> `del list1[0:3]` |
2.52.6 | LIST - deleting elements using value | ...deleting 1st element >>> `list1.remove('item value')`  |
2.52.7 | LIST - sorting in ascending | >>> `list1.sort()` |
2.52.8 | LIST - reversing | >>> `list1.reverse()` |
2.52.9 | LIST - finding the index of the 1st occurance of an element | >>> `list1.index(value)` |
2.52.10 | LIST - ACCUMULATOR | |
2.52.10.1 | list1.append() | | 
2.52.10 | LIST - finding the count of elements | >>> `list1.count(value)` | 
2.53 | ***STRING METHODS*** | |
2.53.1 | STRING - .upper() and .lower() | string1.upper() changes to all upercase, string1.lower() changes to all uppercase | 
2.53.2 | STRING: .count('char') | >>> `string.count('character(s)')`, counts the number of times a character appeared | 
2.53.3 | STRING: .strip() | string.strip() removes any white spaces before and after the actual characters, for example '   this is a string   ' will be changed to 'this is a string'
2.53.4 | STRING: .replace(, ) | >>> `string.replace('char(s)', 'repalcement')`  | 
2.53.5 | STRING: index('char(s)') | >>> `string.index('boy')` ... will return the first occurance of the variable | 
2.53.6 | STRING: format string ...string.format(var1, var2) | >>> string1 = "This is part 1 of the string {:,.2f} This is part 2 of the string {,.2f} - This is part 3 of the string".format(var1, var2) |
2.54 | LIST - alias vs cloning | alias will not create a new copy, just give it a new name, any change in the central will lead to a change in all aliases, eg list2 = list1 ... any change in list1 will be automatically reflected in list2 |
2.54.1 | LIST - cloning | ... >>> `list2 = list1[:]`  OR `list2 = list1 * 1` , this will create a clone with a new address and independent of the original list |
....Corey....2.43 | ** **Classes** ** | https://www.youtube.com/watch?v=ZDa-Z5JzLYM&list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc | 
2.43.1 | Classes - what/why? | Class is an object constructor - can be used to create user defined objects that are used to logically group our data and functions in way that is easy to use/reuse and also easy to build upong if need be, can be used as a 'blueprint' so that we don't have to do it manually for each time |
2.43.2 | Instances | The class (blueprint) is used to create an instance of the class...each unique employee/student record that we create is an instance of the class  |
2.43.3 | Class variables and Instance variables | one way is to create an empty class and then instantiate an instance and create individual instance variable and give them values >>>`class Employee:` (nextline) `pass`  ... instantiating - >>>> `emp_1 = Employee()` ...giving values >>> `emp_1.first = 'Govind'` | 
misc | Decorators | https://www.youtube.com/watch?v=FsAPt_9Bf3U | 
misc | Generators | https://www.youtube.com/watch?v=bD05uGo_sVI | 
misc | if __name == main | https://www.youtube.com/watch?v=sugvnHA7ElY | 
2.43.2 | data and functions in a Class | are called attributes and methods | 
2.44 | Sorting algos in Python | https://medium.com/@george.seif94/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889 https://stackabuse.com/sorting-algorithms-in-python/ https://www.tutorialspoint.com/python_data_structure/python_sorting_algorithms.htm |
**3.0** | **Kaggle Course - 2/18** | **Pandas - https://www.kaggle.com/learn/pandas** |
3.1 | Pandas | the most polular Python library for Data Analysis |
3.2 | Importing Pandas | `import pandas as pd` |
3.3 | Creating Data | Two core objects in Pandas - the **DataFrame** and the **Series** |
3.4 | ***Series*** | A sequence of data values or a list >>> `<Series1> = pd.Series(<list>)` |
3.4.1 | Optional index and Series name | `Series1 = pd.Series(<list>, index = [...], name ='list_name`)...the series name can act as the column if the series is used to create a df |
3.5 | DataFrame | it is a Table, contains a 2x2 array of individual entries, each has a certain value. Each enty corresponds to a row (or a record) and a column |
3.5.1 | Creating df - 1/3 ...creating an empty df and then adding columns | >>> `df = pd.DataFrame()` -> `df['Column 1] = [<list>]` | 
3.5.2 | Creating df - 2/3 ...entering complete columns (dictionay of lists) ***enter 1 outer dictionary with each key-value pair representing 1 entire columns, column values enclused in []*** |  >>> `df = pd.DataFrame({'Name':['GSP', 'PSP ,'DSP'], 'Favorite Color':['Red', 'Blue ,'Green']}) ` |
3.5.3 | Creating df - 3/3 ...entering 1 row at a time (list of dictionaries) ***enter 1 outer list with each dictionary inside representing 1 entire row*** | >>> `df = pd.DataFrame([{'Name':'GSP', 'Favorite Color':'Red'},{'Name':'PSP', 'Favorite Color':'Blue'},{'Name':'DSP', 'Favorite Color':'Green'} ]) ` |
3.6 | Optional index | >>> `pd.DataFrame(<dict>, index = ['index1','index2',...]) ` |
3.6.1 | naming the default index column | `df.index.name = '<index_name>'` |
3.6.2 | checking the shape of a df | `df.shape` |
3.6.3 | **Sample dataset** | https://www.kaggle.com/carlolepelaars/toy-dataset |
3.7 | reading a CSV file into a df | `df = pd.read_csv('file path')` |
3.7.1 | reading a CSV and using one of its columns as index | >>> `pd.read_csv('file path', index_col=0)`...this is not a very good way as one could end up using a column that has duplicate values(s), thus the index will not be unique |
3.8 | reading a CSV file in a ZIP file into a df | https://github.com/Govind-Patwal/European_Hotel_Analysis/blob/main/Data_Preprocessing/Step1_Deleting_Null_Values_and_dividing_into_2_tables.ipynb |
3.9 | checking the shape of a df | `df.shape` |
3.10 | checking the first and last 10 rows | >>>`df.head()` >>> `df.tail()` |
3.12 | choosing a column from the CSV as the index | `pd.read_csv('file path', index_col=<column_number>)` |
3.13 | saving to a CSV file | `df.to_csv('<file_path>)` |
3.13.1| w/o the index | `<df>.to_csv('<file_path>, index = False)` |
3.14 | ***Accessing Data*** |  |
3.14.1 | Accessing data using Columns name first...output is a series | >>>`df['column_name']`, accessing a value (column -> row)  >>>`df['column_name'][<row_index>]`....or first 10 rows of a column >>> `df['column_name'][:10]` |
3.14.1.1 | Choosing only some columns of a df, can also used to reorder columns | >>> `new_df = df[['column1', 'column2', 'column3']]` |
3.14.2 | index based selection - Accessing using Rows index first, followed by column index...iloc | >>> `df.iloc[<row_index_number>,<column_index_number>]`...eg >>> `df.iloc[:10, :4]` >>> `df.iloc[:4, :]` >>> `df.iloc[:, :3]` ...can also be used like >>> `df['column_label'].iloc[0]` |
3.15 | label-based selection - Accessing using Rows index first, followed by column label(s)...loc | >>> `df.loc[<row_index_number>, 'column_name']`        ...eg >>> `df.loc[:10, ['column1_name', 'column2_name', 'column3_name']]`...can also be used like >>> `df['column_label'].loc[0]` ...conditional >>> `df.loc[df['column_name'] == 'Italy']` |
3.16 | choosing between iloc and loc | `df.iloc[:10]` will return 10 values while `df.loc[:10]` will return 11 values...reason: iloc is purely index based, [0:10] will return 10 values (0,1....9)....on the other hand loc is label based so both the start and end points are included, so [0:10] will return 11 values (0,1,2...11)...it is specifically good for situations when you want both the labels/end_points incldued...eg `df.loc[,'GradeA':'GradeD']` |
3.17 | Removing the default index and replacing with a column in the df (the values in column should be unique) | >>> `df.set_index('<column_name_with_unique_values_in_rows>')` | misc
3.18 | naming the default index column that has no name | `df.index.name = '<index_name>'` |
3.19 | Conditional selection | >>> `df['column_label'] == 'Str'/num` ...this produces a series of True/False, which can be used inside a `loc` to select the relevant data |
3.20 | Using loc for selecting data based on conditional | >>> `df.loc[df['Column_label'] <conditinal operation>]` |
3.21 | using and and or | use the signs `&` and `|` |
3.22 | Pandas built in conditional selector - 1/3 `.isin([x,y,z])` | .isin([Value1, Value2, Value3,...]) , it checks if a value is in the list given, for example >>> `df.loc[df['City'].isin(['New Delhi', 'Bangkok', 'Toronto'])]`, it is short form of writing city is in New Delhi or Bangkok or Toronto |
3.23 | Pandas built in conditional selector - 2/3 `.between() `| .between(Value1,Value2)...it checks if a value is between the given range (as in loc, both end points are included), for example >>> `df.loc[df['Salary'].between(50000,80000)]` |
3.24 | Pandas built in conditional selector - 3/3 `.isnull()` `. isnotnull()` | .isnull() and isnotnull() ...to check if the value in a column is null or not, for example >> `df['Salary'].notnull()` |
3.25 | Assigning data to column(s) | `df['Cities'] = 'New City'` or `df['Salary of Employee'] = 50000` |
3.26 | Assigning data based on conditions | `df.loc[df['column_label'] <conditional expression>, 'column_name'] = value`, for example >>> `df.loc[df['Income'].between(40367.0,93669.0), 'Income'] = 50000` |
3.26.1 | Assigning reverse index | >>> `df['index_backwards'] = range(len(df), 0, -1)` |
3.27 | setting the max number of rows to be displayes in a jupyter notebook | >>> `pd.set_option("display.max_rows", 5)` |
3.28 | **Summary function and maps** | involves operations that we can apply to the data to get the 'desired input' |
3.29 | some summary functions | >>>`df['column_label'].describe()` >>>`df['column label'].mean()` >>>`df['column label'].min() `>>>`df['column label'].max()` >>>`df['column label'].median()` >>>`df['column label'].count() `>>>`df['column label'].unique()`....to find the name and frequency of unique values >>> `df['column_name'].value_counts()`, returning of the index of the max value in a column >>> `df['column_name'].idxmax()` |
3.30 | Pandas (operations to create new columns in a jiffy)  | >>> `df['<new_column>'] = df['<column_1>'] + df['<column_2>']` + ' ' ...all mathimatical operations can be done, some more examples >>> `df['<new_column>'] = df['<column_1>'] - df['<column_1>'].mean() |
3.31 | [Maps and apply](https://www.kaggle.com/residentmario/summary-functions-and-maps) - ways to to more advanced things likes applying conditional logic, anything needing a function | extremely useful for transforming data into new one |
3.31.1 | map() used to transform a single column | syntax >>> `map(function, iterables)`...IMP-by default it points to the location where the output is saved, in order to see the actual output use `list(map())` or `pd.Series(map())` eg, >>> `pd.Series(map((function, iterable))`...another way of using the map function >>> `<Series>.map(function) `, for example, >>> `df['<column_label>'].map(function)` |
3.31.1.1 | a use of map() function for formatting columns | `df['column_name'] = df['column_name'].map('{:,.2f}'.format)` | 
3.31.2 | apply() used to transform rows/columns in a df |  >>> `df['column_label'].apply(function)` |
3.32 | [**Grouping and Sorting**](https://www.kaggle.com/residentmario/grouping-and-sorting) | using groupby() |
3.33 | Groupwise analysis - groupby([]) | very handly funciton to group and work with dataframes ... creates a multi index df/Series ... to create a simple df with columns use >>> df.groupby([clm1, clm2...]).count() ... to create a series >>> df.groupby([clm1, clm2...]).size() |
3.33.1 | df.groupby(['column_label_1','column_label_2',... ]) | creates a group of similar valued entries from the column in a df, there can be 1 or multiple columns |
3.33.2 | groupby() is used with another function that applies some operation to the same or any other column | syntax >>> `df.groupby(['Column(s) to be used for grouping'])['Column_to_be_operator_on'].<operation()>`...eg, `df.groupby(['country','state'])['population'].max())`...functions could be min(), max(), count()...we can also use the pandas function `apply()` can be used with groupby(), [example from kaggle pandas course](https://www.kaggle.com/residentmario/grouping-and-sorting) or example, here's one way of selecting the name of the first wine reviewed from each winery in the dataset: >>> `reviews.group(['winery']).apply(lambda df: df['title'].iloc[0])` |
3.33.3 | agg()...good function to have many funtion run together | `df.groupby(['Column_to_be_used_for_grouping])['Column_to_be_operated_on'].agg[('len','min','max')]`....this returns a dataframe |
3.33.4 | more than one columns can be grouped | `df.groupby(['column1','column2',...])['<column_to_be_operated_on>'].<sum/count/min/max()>` OR `df.groupby(['Column1'],['Column2'],...).apply(<function>)` |
3.34 | Resetting index after multi-group groupby() | `df.groupby(['Column1', 'Column2']).reset_index()` |
3.35 | **Sorting** | |
3.35.1 | Soring by index |  `df.groupby(['Column1'],['Column2'],...).sort_index()` |
3.35.2 | Sorting by single value (while using groupby) | `df.groupby([<column(s) to be used for grouping rows],...).sort_values(by=['len'])` OR `df.groupby(['Column1'],['Column2'],...).sort_values(by=['len'], ascending=False)` |
3.35.3| Sorting by multiple values (while using groupby) | `df.groupby([<column(s) to be used for grouping rows],...).sort_values(by=['len', <a column used for grouping>])`...eg `df.groupby(['country', 'state']).sort_values(by=['len', 'state'])` ...if we want all descending then use, ascending =False, eg >>> `df.groupby(['country', 'state']).sort_values(by=['len', 'state'], ascending=False)`...can also use size() and sort_values, eg. >>> `df.groupby(['country', 'state']).size().sort_values()` |
3.35.4 | General sorting a df by a column | >>> `df.sort_values(by=['Column1'], ascending= False)` |
3.36 | **Data Types and Missing Values**| Credit - https://www.kaggle.com/residentmario/data-types-and-missing-values |
3.37 | dtype and dtypes | dtype is for a column, and a dtypes is for df...>>> `df.dtypes ` >>> `df['column_label'].dtype`....strings will show was 'O' meaning object...NOTE: to access the values/types of the index column, use >>> `df.index.dtype` and NOT df['index'].dtype (index is not a column) |
3.37.1 | converting datatype of column | >>> `df['column label'].astype('str')`...other formats could be 'float64' 'int64' |
3.38 | Missing Data | checking the null in all columns of df >>>`df.isnull().sum()`, checking the null in a specific column >>> `df['column_label'].isnull().sum()` ...creting a df based on null in a column >>> `df.loc[df['required_clmn'].isnull() == True]`...checking for data that is not null >>> `df['column_name'].notnull().sum()` and >>> `df['column_name'].notna().sum()` |
3.38.1 | replacing na with something | >>> `df['column_label].fillna('Unknown')`...you can also replace using the mean of the column, or use the backfill strategy (filling each missing with the next non-null) ...replacing non-null with something else >>> `df['column_label'].replace('value_to_replace', 'new_value')`...replace() is also handy when column has data like 'unknown', 'no known', etc, that need to be replaced |
3.38.2 | replacing soemthing with something else | >>> `df['Column name'].replace('old_text', 'new_text')`
3.39 | **Renaming and Combining** | Credit - https://www.kaggle.com/residentmario/renaming-and-combining |
3.40 | Renaming columns | renaming column names >>> `df.rename(columns={'column_1_existing_name':'column_1_new_name', 'column_2_existing_name':'column_2_new_name'})` |
3.41 | naming or renaming the default index column |  >>> `df.index.name = '<new_index_name>'` |
3.41.1 | Renaming index rows | renaming default index rows  >>> `df.rename(index={0:'row_1_name', 1:'row_2_new_name'})` |
3.42 | Removing the default index and replacing with a column in the df | >>> `df = df.set_index('[<column_name_with_unique_values_in_rows>'])` |
3.43 | resetting the index from 0...-1 | >>> `df.reset_index()` |
3.44 | renaming index values | changing the first and second index names, ie. index[0] and index[1] >>> `df.rename(index={0:'FirstEntry', 1:'SecondEntry'})` |
3.45 | renaming both x and y axis | >>> `df.rename_axis('row_axis_name', axis ='rows').rename_axis('column_axis_name', axis='columns')` |
3.45.1 | Dropping columns | >>> `df.drop('column name', axis=0, inplace = True)` OR >>> `df.drop(columns = 'column name', inplace=True) ` | 
3.45.2 | Dropping rows | >>> `df.drop('row index', axis=1, inplace = True)`  | 
3.46 | Combining dataframes | used to combine 2 or more dataframes into 1 |
3.46.1 | concat()...used when the columns are exactly the same | >>> `pd.concat(['df1','df2'])` |
3.46.2 | join()...have 1 or more common columns | >>>`left_df.set_index(['common_column(s)']).join(right_df.set_index(['same_common_column(s)']))` |
3.46.2.1 | join() ...where the dfs has the same column names but both are required | >>> `df1.set_index([column_name(s)].join(df2.set_index([same_column_name(s)])), lsuffix='_left_DF', rsuffix='_right_DF')` 
3.46.3 | merge ()...used when columns are not the same but their is one common column | >>> `new_df = df1_bigger_df.merge(df2_smaller_df, on='common_column')`...NOTE: use the bigger table as df1 |
3.47 | ***Pandas - UofT Data Bootcamp*** | | 
3.48 | checking for number of values  | in all the columns of the df >>>`df.count()` ...in specific columns of df >>> `df['Column_name'].count()`  | 
3.48.1 | checking for missing data (na and null)| >>>`df.count()` >>>`df.isna().sum()` >>>`df.notna().sum()` >>>`df.isnull().sum()`  >>>`df.notnull().sum()` | 
3.48.2 | handling missing data (na and null)| (1) drop all rows with na >>> df.dropna() ...(2) fill na with some value >>> `df.fillna(number)`  ...(3) replacing values >>> `df.replace('present_value', 'new_value')` | 
3.48.3 | finding unique elements in a column | >>> `df['column name'].unique()` ...can find its length >>> len(df['column name'].unique()) |
3.49 | 6 data types | `bool`, `int32`, `int64`, `float64`, `O, object`, `datetime64`   |
3.49.1 | checking data types | checking data types of a df >>> `df.dtypes ` ...chekcing data types of a column >>> `df['column_name'].dtype` | 
3.50 | converting a df column to a list | >>> `df['column_name'].tolist()` |
3.51 | splitting a string | >>> `string.split()`  |
3.52 | returning unique elements from a list, and arranged in ascending order | >>> `set(list)` |
3.53 | string.strip() and string.replace(x,y) | ..replacing with an empty string >>> `new_string = string.replace(x, '')` ...IMP-for it to work, it has to be assigned to a new variable | 
3.54 | always better to change entire column INSTEAD of looping through individual values of the column | >>> `df['column_name'] = df['Column_name']*transformation_steps` is BETTER than >>> `for item in column: do_something` | 
3.55 | selecting and dropping columns | |
3.55.1 | selecting columns from a df | >>> `df = df[['Column1', 'Column2', 'Column3']]` | 
3.55.2 | dropping columns from a df | >>> 'df = df.drop('column1, axis=1, inplace=True) | 
3.55.3 | changing the position of columns in a df | >> 'df = df[['Column in 1st position', 'Column in 2nd position', 'Column in 3rd position']] |
**4.0** | ***Matplotlib*** | Source - https://bootcamp.learn.utoronto.ca/data/  | 
4.1 | importing the library | >>> `import matplotlib.pyplot as plt` (nextline) >>> `%matplotlib inline` | 
4.2 | showing the plot...at the end of the code| >>> `plt.show()` | 
4.3 | line charts commands | | 
4.3.1 | changing the size of graph in pixels...this goes as the first line while plotting the graph | >>> plt.figure(figsize=(w, h)) | 
4.3.2 | basic plotting of the graph | >>> `plt.plot(x_axis, y_axis)` ...x_axis and y_axis are lists of equal length ...x_axis = [], y_axis = [] | 
4.3.2.1 | adding to the basic plot | >>> `plt.plot(x_axis, y_axis, label='name_of_legend', marker = '*', color = 'green', linewidth = 2)` ...label has to be followed on the next line by >>> `plt.legend()` | 
4.3.3 | >>> `plt.xlim(min, max)` | setting the minimum and maximum limit of x-axis | 
4.3.4 | >>> `plt.ylim(min, max)` | setting the minimum and maximum limit of y-axis | 
4.3.5 | >>> `plt.xlabel('X-label')` | x-axis label | 
4.3.6 | >>> `plt.ylabel('Y-label')` | y-axis label | 
4.3.7 | >>> `plt.title('Title')` | Title of the graph | 
4.3.8 | >>> `plt.grid()` | addign grid to the chart | 
4.3.9 | >>> `plt.savefig('add the path with the extension)` | ... at the end of the code, save the chart with the extension | 
z.0 | **Django** | Credits: https://www.youtube.com/watch?v=OTmQOjsl0eg and https://www.youtube.com/watch?v=F5mRW0jo-U4 and https://www.youtube.com/playlist?list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p | The most popular web-dev framework for Python
4.1 | MVC in other back-end languages to build good web-dev application - Model View Controller - Model for data, View for HTML format, and Controller to control the entire operation | 
4.2 | In Django we have MVT | Model, View, Template | 
4.3 | Why Django | Fast, many available components, Security, Scalability
4.4| Creating and Running a new Django project | (Step1) Win command prompt... (Step2) C:\Users\user_name>`D:`... (Step3) `D:\>cd folder_location`... (Step4) D:\folder_location>`pip install virtualenvwrapper-win`... (Step5) D:\folder_location>`mkvirtualenv <virtual_environment_name>`... (Step6(virtual_environment_name)D:\folder_location>`pip install django`... (Step7) (virtual_environment_name)D:\folder_location>`django-admin startproject <new_project_name>`... (Step8) (virtual_environment_name)D:\folder_location>`cd new_project_name`... (Step9)(virtual_environment_name)D:\folder_location\new_project_name>`python manage.py runserver`
4.4.1 | initiating a virtual environment | 1) file_path>`workon 'virtual_environment_name'`... 2) (virtual_environment_name)file_path>
4.5 | settings.py | ALWAYS turn `Debug = False` before making the project live | 
4.6 | VS Code - Integrated terminal - setting default (cmd vs powershell) | 1) Open VS code... 2)Press Ctrl + Shift + P... 3)Type 'shell' in the searcher... 4)Select 'Terminal: Select Default Shell'... 5)Select 'Command Prompt' or 'Windows Powershell'  | 
4.7 | all Django main commands| >>> `django-admin` |
4.8 | help while working on Django | >>>`python manage.py help` | ...to return after the Canvas course
**5.0**| 

</details>

---

### SOME MORE PYTHON COURSES
<details>
<summary>Click to Expand/Collapse</summary>

- https://docs.python.org/3/tutorial/index.html
- https://wiki.python.org/moin/BeginnersGuide/NonProgrammers
- https://wiki.python.org/moin/BeginnersGuide/Programmers
- https://www.dj4e.com/lessons 
- intermediate python - https://book.pythontips.com/en/latest/index.html

</details>  

---

Video tutorials can also break things down when I am stuck - https://www.youtube.com/watch?v=7HN-4Df8ZpA


- Clone of good apps - https://www.sparkouttech.com/grubhub-clone/

---
### Job_search_keywords (for best result - use in combination)
- Very Good article - ***https://www.kdnuggets.com/2018/01/feizpour-becoming-data-scientist.html***

intern, internship
data analytics, data engineer
python engineer, python programmer

Google.com
Indeed
LinkedIn
Glassdooor

---

### Good_Links

<details>
<summary>Click to Expand/Collapse</summary>

### Links to Courses / Credits
- https://www.kaggle.com/learn/overview
- https://www.kaggle.com/learn/python 

### Links to profiles
- https://bluink.ca/
- https://bierman.io/
- https://github.com/BiermanM/job_scraper
- https://brittanyfortner.com/ 

- Stackoverflow

- https://aws.amazon.com/developer/language/python/?nc1=f_dr

- https://medium.com/@sjacks/using-rds-on-aws-with-jupyter-notebooks-c2703299fcc8
- https://towardsdatascience.com/amazon-rds-step-by-step-guide-14f9f3087d28
- https://amazon-rds.totableau.com/
- https://www.youtube.com/watch?v=PHsApsvZKNI
- some good GitHub page website - https://github.com/collections/github-pages-examples
- govind.github.io
- netflix.github.io
- https://github.com/Netflix/netflix.github.com

- http://twitter.github.io
- http://twitter.github.io/labella.js/

- Word to HTML converter - https://wordtohtml.net/
- Screen Capture (on Windows Appstore) - https://getsharex.com/
- Tech Interview Practice - https://leetcode.com/
- Kaggle



- https://www.youtube.com/watch?v=F5mRW0jo-U4




- Python on AWS - Mount the EFS to your Lambda function, intall dependencies on the EFS - https://www.youtube.com/watch?v=4cquiuAQBco
- Group Project - ML model on AWS - https://github.com/asadca4u/Final_Project_Group_Five 
- Group Project - Good Tableau - https://public.tableau.com/profile/kassie.lu#!/vizhome/AmesHousingSalesPricesDashboard/Dashboard?publish=yes

</details>

---

### Project_Ideas
<details>
<summary>Click to Expand/Collapse</summary>

***Banking*** - some very useful projects that are good for the resume and portfolio:
- Credit Fraud Detection: https://www.kaggle.com/mlg-ulb/creditcardfraud
- Customer Segmentation: https://www.kaggle.com/vjchoudhary7/customer-segmentation-tutorial-in-python
- Two Sigma Financial Modeling: https://www.kaggle.com/c/two-sigma-financial-modeling
- The Winton Stock Market Challenge: https://www.kaggle.com/c/the-winton-stock-market-challenge
- New York Stock Exchange: https://www.kaggle.com/dgawlik/nyse
- Lending Club Loan Data: https://www.kaggle.com/wendykan/lending-club-loan-data
- Financial Machine Learning and Data Science: https://github.com/firmai/financial-machine-learning
- https://www.kaggle.com/arjunjoshua/predicting-fraud-in-financial-payment-services

</details>

---

### Misc
<details>
<summary>Click to Expand/Collapse</summary>

- https://cloud.google.com/blog/topics/training-certifications/kick-off-2021-with-skill-badges-and-free-training

- https://towardsdatascience.com/6-data-science-certificates-to-level-up-your-career-275daed7e5df 

</details>

---